[[go-getting-started]]
= 入门

[[go-getting-started-install]]
== 安装

具体安装教程参考下面链接

https://go-zh.org/doc/install[https://go-zh.org/doc/install]

GOROOT:GOROOT就是 go 的安装路径

GOPATH:是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。

GOPATH之下主要包含三个目录:

* bin:主要存放可执行文件;
* pkg:存放编译好的库文件,主要是*.a文件
* src:主要存放go的源文件

[IMPORTANT]
====
不要把 GOPATH 设置成 go 的安装路径,
可以自己在用户目录下面创建一个目录, 如 gopath
====

[[go-getting-started-hello-world]]
== Hello World

====
[source, go]
----
package main <1>

import "fmt" // 实现格式化的 I/O <2>

/* Print something */ <3>
func main() { <4>
	fmt.Printf("Hello World") <5>
}
----
<1> 首行这个是必须的。所有的 Go 文件以 package <something> 开头，对于独立运行的执行文件必须是 package main；
<2> 这是说需要将fmt 包加入 main。不是 main 的其他包都被称为库。末尾以 `//` 开头的内容是注释；
<3> 这同样是注释，不过这是被包裹于 `/*` 和 `*/` 之间的；
<4> package main 必须首先出现，紧跟着是 import。在 Go 中，package 总是首先出现，然后是 import，然后是其他所有内容。当 Go 程序在执行的时候，首先调用的函数 是 main.main()，这是从 C 中继承而来。这里定义了这个函数；
<5> 调用了来自于 fmt 包的函数打印字符串到屏幕。字符串由 `"` 包裹，并且可以包含非 ASCII 的字符。
====

[[go-getting-started-run]]
== 编译和运行代码

构建 go 程序的最佳途径是使用 go 工具,下面使用两种执行流程

=== 先编译，再执行
如上面的程序，要对其进行编译，只需要执行以下指令

[source, shell]
----
go build helloworld.go
----

构建的结果是 名为 helloworld 的可执行程序(windows 下是 `.exe` 文件，Linux 下是一个可执行文件)。然后运行

[source, shell]
----
./helloworld
----

=== 直接编译运行

或者我们可以直接使用 `go run` 命令编译运行，一步到位。

[source, shell]
----
go run helloworld.go
----

.两种执行流程的区别
****
* 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有 go 开发环境的机器上，仍然可以运行
* 如果使用 `go run` ，那么如果要在另外一台机器上使用，也需要 go 开发环境，否则无法执行
* 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所有，可执行文件大了许多
****

[[go-getting-started-notice]]
== 程序开发注意事项

. Go 源文件以 "go" 为扩展名
. Go 应用程序的执行入口是  main() 函数，这个是和其他编程语言(例如 java,c)一样。
. Go 语言严格区分大小写
. Go 方法由一条条语句构成，每个语句后面不需要分号(Go 语言会自动在每行后加分号)
. Go 编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一行，否则报错
. Go 语言定义的变量或者 import 的包如果没有使用到，代码不能编译通过
. 大括号都是成对出现的，不可省略

[[go-getting-started-specification]]
== Golang 代码规范

* Golang 官方推荐使用行注释来注释整个方法和语句
* 正确的缩进和空白，使用 gofmt 命令进行格式化
* 运算符两边习惯各加一个空格
* 大括号必须跟在语句后面，不能单起一行。
* 一行最多不超过80个字符

[[go-getting-started-guide]]
== Golang 官方编程指南

官方网站: https://tour.golang.org/list[https://tour.golang.org/list]
中文网站: http://go-tour-zh.appspot.com/list[http://go-tour-zh.appspot.com/list]

[[go-getting-started-escapes]]
== Golang 转义符

[[go-getting-started-escape-tbl]]
.常用转义符
|===
| 转移字符 | 描述

| \a
| 响铃

| \t
| 表示一个制表符，通常使用他排版

| \n
| 换行符

| \r
| 一个回车

| \b
| 退格

| \f
| 换页

| \v
| 垂直制表符

| \\
| 一个 \

| \"
| 一个 "

| \\
| 反斜杠
|===

[[go-getting-started-identifier]]
== Golang 标识符

Golang 对各种方法，函数，变量，自定义等命名时使用的字符序列称为标识符

标识符命名规则：

. 由 26 个英文字母大小写，0-9，_ 组成
. 数字不可以开头
. Golang 中严格区分大小写
. 标识符不能包含空格
. 下划线 `_` 本身在 Go 中是一个特殊的标识符，称为空标识符，可以代表任何其他的标识符，但是它对应的值会被忽略（比如，忽略某个返回值）。**所以仅能被作为占位符使用，不能作为标识符使用**
. 不能以系统<<go-getting-started-key>>作为标识符(25 个)

标识符命名注意事项

. 包名：保持 package 的名字和目录一致,尽量采取简短，有意义的包名，不要和标准库冲突
. 变量，函数，常量名采用驼峰式
. 如果变量名，函数名，常量名首字母大写，则可以被其他的包访问，如果首字母小写，只能在本包中使用

[[go-getting-started-key]]
== 系统保留关键字

25 个

----
break       default     func	interface	select
case        defer       go      map	        struct
chan        else        goto    package	    switch
const       fallthrough if      range	    type
continue    for         import  return	    var
----

[[go-getting-started-pre-identifier]]
== 系统预定义标识符

36 个

----
append	bool	byte	cap	    close	complex	complex64	complex128	uint16

copy	false	float32	float64	imag	int	    int8	    int16	    uint32

int32	int64	iota	len	    make	new	    nil	        panic	    uint64

print	println	real	recover	string	true	uint	    uint8	    uintptr
----

[[go-getting-started-vars]]
== 变量

与其他语言不同，在 go 语言中，变量的类型在变量名的后面。 例如，声明一个 `int` 类型的 a，是 a int , 而不是 int a.

当定义了一个变量，它默认赋值为其类型的 `null` 值，例如，在 var a int 后， `a` 的值为 `0`, 而 var s string ，`s` 为零长度字符串。也就是 `""`

在 Go 中，声明和初始化是两个过程,但是可以连在一起。以下实例显示了变量的使用方式

[[go-getting-started-vars-define]]
=== 变量的声明

* 基本语言 `var 变量名 数据类型`

变量在未进行初始化前，使用 <<go-getting-started-data-type-default>>
[source, go]
----
package main

import "fmt"

func main(){
	var i int
	fmt.Print("i=",i) //打印结果为 0
}
----

[[go-getting-started-vars-initialization]]
=== 初始化变量

在声明变量的时候就给值，则为初始化变量。可以省略数据类型

* 根据值自行判断类型

[source, go]
----
package main

import "fmt"

func main(){
	var i = 10
	fmt.Print("i=",i)
}
----

* 省略 `var` 也称为 短声明变量, 使用 `:=` 替代 `var` 。 注意，左侧的变量不应该是已经声明过的，且 `:` 不可以省略

[source, go]
----
package main

import "fmt"

func main(){
	i := 10
	fmt.Print("i=",i)
}
----

* 多变量声明

[source, go]
----
package main

import "fmt"

func main(){
	//变量类型一致
	var n1,n2,n3 int
	//变量类型不一致
	var n4,n5,n6 = 100,"tom",666
	//类型推导
	n7,n8,n9 := 200,"cheery",999

	fmt.Println("n1=",n1,"n2=",n2,"n3=",n3)
	fmt.Println("n4=",n4,"n5=",n5,"n6=",n6)
	fmt.Println("n7=",n7,"n8=",n8,"n9=",n9)
}
----

* 一次性声明,使用 `()`

[source,go]
----
package main

import "fmt"

var (
	name = "tom"
	age = 19
)

func main(){

	fmt.Println("name=",name,"age=",age)
}
----

一个特殊的变量名是 `_`（下划线）。下划线意思是忽略这个变量，例如，`f,err := os.Open(xxxxxxx)` 如果此时不需要知道返回的错误值，就可以用 `f, _ := os.Open(xxxxxx)` ,//如此则忽略了error变量。

[[go-getting-started-vars-assignment]]
=== 给变量赋值

在变量声明之后,再赋予变量的值，比如你先声明了变量: `var num int` ,默认为 `0` . 然后，再给值 `num = 100` 。这就是给变量赋值

[[go-getting-started-data-type]]
== 数据类型

Go 中的数据类型主要分为两大块，一块是基本数据类型，一块是复杂数据类型。每一种数据类型都定义了明确的数据类型，在内存中分配了不同大小的内存空间

[[go-getting-started-data-type-base]]
=== 基本数据类型

[[go-getting-started-data-type-base-int]]
==== 整型

当定义了整型类型而没有指定数据类型时，默认使用 `int` 类型

[[go-getting-started-data-type-base-int-tbl]]
.整型类型
|===
| 类型名称 | 有无符号 | 占用存储空间(bit) | 范围 | 备注

| int8	| Yes	| 8 | -128 ~ 127 |

| int16	| Yes	| 16 | -2{caret}15 ~ 2{caret}15-1 |

| int32	| Yes	| 32 | -2^31 ~ 2^31-1 |

| int64	| Yes	| 64 | -2^63 ~ 2^63-1|

| uint8	| No	| 8 | 0 ~ 255 |

| uint16	| No	| 16 | 0 ~ 2^16-1  |

| uint32	| No	| 32 | 0 ~ 2^32-1 |

| uint64	| No	| 64 | 0 ~ 2^64-1 |

| int	| Yes	| 等于cpu位数(32 为系统 4 个字节，64 位系统 8 个字节) |  32 位: -2^31 ~ 2^31-1 64 位: -2^63 ~ 2^63-1 |

| uint	| No	| 等于cpu位数(32 为系统 4 个字节，64 位系统 8 个字节) | 32 位: 0 ~ 2^64-1 64 位: 0 ~ 2^64-1|

| rune	| Yes	| 与 int32 等价 |  -2^31 ~ 2^31-1 | 表示一个 Unicode 码

| byte	| No	| 与 uint8 等价 | 0~255 | 当要存储字符时，选用 byte

| uintptr	| No	| - | |
|===

`rune` 类型是 `Unicode` 字符类型，和 `int32` 类型等价，通常用于表示一个 `Unicode` 码点。`rune` 和 `int32` 可以互换使用。

`byte` 是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是 一个小的整数。

`uintptr` 是一种无符号的整数类型，没有指定具体的bit大小但是足以容纳指针。 `uintptr` 类型只有在底层编程是才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方。

不管它们的具体大小，`int`、`uint` 和 `uintptr` 是不同类型的兄弟类型。其中 `int` 和 `int32` 也是 不同的类型， 即使 `int` 的大小也是 32bit，在需要将 `int` 当作 `int32` 类型的地方需要一个显式 的类型转换操作，反之亦然。

有符号整数采用 `2` 的补码形式表示，也就是最高 bit 位用作表示符号位，一个 `n` bit 的有 符号数的值域是从 `-2^{n-1}` 到 `2^{n-1}−1`。例如，`int8` 类型整数的值域是从 `-128` 到 `127`， 而 `uint8` 类型整数的值域是从 `0` 到 `255`。

[[go-getting-started-data-type-base-float]]
==== 浮点类型

Golang 的浮点型默认声明为 `float64` 类型

[[go-getting-started-data-type-base-float-tbl]]
.浮点类型
|===
| 类型名称  | 占用存储空间(bit) | 范围 | 备注

| 单精度 float32 | 32 | -3.403E38 ~ 3.403E38 |

| 双精度 float64 | 64 | -1.798E308 ~ 1.798E308 |
|===

说明

* 浮点数在机器中存放的形式：浮点数=符号位+指数位+尾位数
* 浮点数是有符号的
* 尾数部分可能丢失，造成精度损失(一个 `float32` 类型的浮点数可以提供大约 `6` 个十进制数的精度，而 `float64` 则可以提供约 `15` 个十进制数的精度).

[[go-getting-started-data-type-base-byte]]
==== 字符类型

Golang 中没有专门的字符类型，如果要存储单个字符（字母），一般使用 `byte` 存储

[NOTE]
====
字符串就是一串固定长度的字符连接起来的字符序列，Go 的字符串是有单个字节连接起来的，也就是说对于传统的字符串是由 **字符** 组成的，而在 Go 中是由 **字节** 组成的
====

====
[source,go]
----
package main

import "fmt"

func main(){
	var c1 byte = 'a'
	var c2 byte = '0'
	var c3 int = '北'
	//当直接输出 byte 值，就是输出了对应字符的 码值
	fmt.Println("c1=",c1," c2=",c2) <1>

	// 如果需要输出对应字符，需要格式化输出
	fmt.Printf("c1=%c c2=%c\n",c1,c2) <2>

	// var c3 byte = '北' // overflow 溢出
	fmt.Printf("c3=%c c3对应的码值=%d",c3,c3) <3>
}
----
<1> 当直接输出 byte 值，就是输出了对应字符的 码值,输出结果为: c1=97 c2=48
<2> 如果需要输出对应字符，需要格式化输出,输出结果为: c1=a c2=0
<3> 如果我们保存的字符在 ASCII 表，比如[0-1,a-z,A-Z] 则可以直接保存到 `byte`。如果保存的字符对应的码值大于 `255` ，这时可以考虑使用 `int` 类型保存.输出结果为:c3=北 c3对应的码值=21271
====

字符串使用细节

* 字符常量使用单引号括(`''`)起来的单个字符。
* Go 中允许使用转义字符 `\` 来将其后的字符转变为特殊字符型常量。例如: var c2 byte = '\n' \n 表示换行符
* Go 语言的字符使用 UTF-8 编码，可以在 http://www.mytju.com/classcode/tools/encode_utf8.asp[这个网站] 查询字符对应的 UTF-8 码值
* 在 Go 中，字符的本质是一个整数，直接输出时，是该字符对应的 UTF-8 编码的码值
* 可以直接给某一个变量赋一个数字，然后使用 `%c` 格式化输出，会输出该数字对应的 unicode 值
* 字符类型可以进行运算，运算时是按照码值进行运算的

[[go-getting-started-data-type-base-bool]]
==== 布尔型

布尔类型也叫 bool 类型，bool 类型只允许取值 `true` 或 `false`,bool 类型占用一个字节

`if` 和 `for` 语句的条件部分都是布尔类型的值，并且 `==` 和 `<` 等比 较操作也会产生布尔型的值。一元操作符 `!` 对应逻辑非操作，因此 `!true` 的值为 `false`。

布尔值可以和 `&&`（AND）和 `||（OR）` 操作符结合，并且可能会有短路行为：如果运算符左边值已经可以确 定整个布尔表达式的值，那么运算符右边的值将不在被求值

布尔值并不会隐式转换为数字值 `0` 或 `1`，反之亦然。必须使用一个显式的 `if` 语句辅助转换。

[[go-getting-started-data-type-base-plural]]
==== 复数

Go语言提供了两种精度的复数类型：`complex64` 和 `complex128`，分别对应 `float32` 和 `float64` 两种浮点数精度。内置的 `complex` 函数用于构建复数，内建的 `real` 和 `imag` 函数分别返回复数的实部和虚部。

复数也可以用 `==` 和 `!=` 进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。 `math/cmplx` 包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。

[source,go]
----
z := x + yi
x = real(z)
y = imag(z)
----

[[go-getting-started-data-type-base-string]]
==== 字符串

Go 语言的字符串是由单个字节连接起来的，Go 语言的字符串的字节使用 UTF-8 编码标识的 Unicode 文本

**Go 语言中的字符串是不可变的**

字符串的两种表现形式

* 双引号：会识别转义字符
* 反引号：以字符串的原生形式输出，包括换行和特殊字符

[[go-getting-started-data-type-complex]]
=== 复杂数据类型

[[go-getting-started-data-type-complex-pointer]]
==== 指针

指针（pointer）在Go语言中可以被拆分为两个核心概念：

* 指针类型，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，指针类型不能进行偏移和运算。
* 切片，由指向起始元素的原始指针、元素数量和容量组成。

===== 指针地址和指针类型

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go 语言中使用在变量名前面添加 `&` 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：

[source,go]
----
ptr := &v    // v 的类型为 T
----

其中 `v` 代表被取地址的变量，变量 `v` 的地址使用变量 `ptr` 进行接收，`ptr` 的类型为 `{asterisk}T`，称做 `T` 的指针类型，`{asterisk}` 代表指针。

====
[source,go]
----
package main
import (
    "fmt"
)
func main() {
    var cat int = 1 <1>
    var str string = "banana" <2>
    fmt.Printf("%p %p", &cat, &str) //0xc042052088 0xc0420461b0 <3>
}
----
<1> 声明整型变量 cat。
<2> 声明字符串变量 str。
<3> 使用 fmt.Printf 的动词%p打印 cat 和 str 变量的内存地址，指针的值是带有 0x 十六进制前缀的一组数据。
====

[TIP]
====
变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。
====

===== 从指针获取指针指向的值

当使用 `&` 操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用 `*` 操作符，也就是指针取值，代码如下。

====
[source,go]
----
package main
import (
    "fmt"
)
func main() {
    // 准备一个字符串类型
    var house = "Malibu Point 10880, 90265" <1>
    // 对字符串取地址, ptr类型为*string
    ptr := &house <2>
    // 打印ptr的类型
    fmt.Printf("ptr type: %T\n", ptr) // ptr type: *string <3>
    // 打印ptr的指针地址
    fmt.Printf("address: %p\n", ptr) // address: 0xc0420401b0 <4>
    // 对指针进行取值操作
    value := *ptr <5>
    // 取值后的类型
    fmt.Printf("value type: %T\n", value) // value type: string <6>
    // 指针取值后就是指向变量的值
    fmt.Printf("value: %s\n", value) // value: Malibu Point 10880, 90265 <7>
}
----
<1> 准备一个字符串并赋值。
<2> 对字符串取地址，将指针保存到变量 ptr 中。
<3> 打印变量 ptr 的类型，其类型为 *string。
<4> 打印 ptr 的指针地址，地址每次运行都会发生变化。
<5> 对 ptr 指针变量进行取值操作，变量 value 的类型为 string。
<6> 打印取值后 value 的类型。
<7> 打印 value 的值。
====

取地址操作符 `&` 和取值操作符 `{asterisk}` 是一对互补操作符，`&` 取出地址，`{asterisk}` 根据地址取出地址指向的值。

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

* 对变量进行取地址操作使用 `&` 操作符，可以获得这个变量的指针变量。
* 指针变量的值是指针地址。
* 对指针变量进行取值操作使用 {asterisk} 操作符，可以获得指针变量指向的原变量的值。

===== 使用指针修改值

通过指针不仅可以取值，也可以修改值。

前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：

====
[source,go]
----
package main
import "fmt"
// 交换函数
func swap(a, b *int) { <1>
    // 取a指针的值, 赋给临时变量t
    t := *a <2>
    // 取b指针的值, 赋给a指针指向的变量
    *a = *b <3>
    // 将a指针的值赋给b指针指向的变量
    *b = t <4>
}
func main() {
// 准备两个变量, 赋值1和2
    x, y := 1, 2 <5>
    // 交换变量值
    swap(&x, &y) <6>
    // 输出变量值
    fmt.Println(x, y) // 2 1 <7>
}
----
<1> 定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。
<2> 取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。
<3> 取 b 的指针值，赋给指针 a 指向的变量。注意，此时*a的意思不是取 a 指针的值，而是“a 指向的变量”。
<4> 将 t 的值赋给指针 b 指向的变量。
<5> 准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。
<6> 取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。
<7> 交换完毕时，输出 x 和 y 的值。
====

`{asterisk}` 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，`{asterisk}` 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。

如果在 `swap()` 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：

[source,go]
----
package main
import "fmt"
func swap(a, b *int) {
    b, a = a, b
}
func main() {
    x, y := 1, 2
    swap(&x, &y)
    fmt.Println(x, y) // 1 2
}
----

结果表明，交换是不成功的。上面代码中的 `swap()` 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。

.创建指针的方法
****
Go语言还提供了另外一种方法来创建指针变量，格式如下：

new(类型)

一般这样写：

[source,go]
----
str := new(string)
*str = "Go语言教程"
fmt.Println(*str)
----
****

[[go-getting-started-data-type-default]]
=== 零值(默认值)

[[go-getting-started-data-type-default-tbl]]
.零值
|===
| 数据类型 | 默认值

| 整型
| 0

| 浮点型
| 0

| 字符串
| ""

| 布尔类型
| false
|===

[[go-getting-started-data-type-convert]]
=== 数据类型转换

Golang 和 java/c 不同，Go 在不同类型的变量之间赋值时需要显示转换。也就是说 Golang 中数据类型不能自动转换

==== 基本数据类型转换

表达式 T(v) 将值 v 转换为类型 T

T : 就是数据类型,比如 int32,int64,float32
v: 就是需要转换的变量

====
[source,go]
----
package main

import (
	"fmt"
)
func main()  {
	var n1 int32 = 100

	var n2 float32 = float32(n1) <1>

	var n3 int8 = int8(n1) <2>

	var n4 int64 = int64(n1) <3>

	fmt.Printf("n1=%v n2=%v n3=%v n4=%v",n1,n2,n3,n4)
}
----
<1> 将 n1 转换为 float32 类型
<2> 将 n1 转换为 int8 类型
<3> 将 n1 转换为 int64 类型
====

[NOTE]
====
* 被转换的是变量存储的数据（即值），变量本身的数据类型并没有变化！
* 在转换中，比如将 int64 转为 int8 ，编译时不会报错，只是转化结果按溢出处理。因此在转换时，需要考虑范围
====

==== 基本数据类型转 string 类型

* func Sprintf(format string, a ...interface{}) string

[source,go]
----
package main

import "fmt"

func main(){
	var num int = 0
	var num2 float64 = 23.456
	var b bool = true
	var mychar byte = 'h'
	var str string

	str = fmt.Sprintf("%d",num)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="0"

	str = fmt.Sprintf("%f",num2)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="23.456000"

	str = fmt.Sprintf("%t",b)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="true"

	str = fmt.Sprintf("%c",mychar)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="h"
}
----

* 使用 strconv 包的函数

[source,go]
----
package main

import (
	"fmt"
	"strconv"
)

func main(){
	var num3 int = 23
	var num4 float64 = 23.456
	var b2 bool = true
	var str string

	str = strconv.FormatInt(int64(num3),10)
	fmt.Printf("str type %T str=%q\n",str,str) // str type string str="23"

	str = strconv.FormatFloat(num4,'f',10,64)
	fmt.Printf("str type %T str=%q\n",str,str) // str type string str="23.4560000000"

	str = strconv.FormatBool(b2)
	fmt.Printf("str type %T str=%q\n",str,str) // str type string str="true"
}
----

====  string 类型转基本数据类型

* 使用 strconv 包的函数

[source,go]
----
package main

import (
	"fmt"
	"strconv"
)

func main(){

	var str1 string = "64"
	var str2 string = "25.3664"
	var str3 string = "false"
	// strconv.ParseInt 返回值为 int 64,如果需要得到 int 8

	num1,_ := strconv.ParseInt(str1,10,32)
	fmt.Printf("num1 type %T num1=%v\n",num1,num1) // str type string str="23"

	f1,_ := strconv.ParseFloat(str2,10)
	fmt.Printf("f1 type %T f1=%v\n",f1,f1) // str type string str="23"

	b1,_ := strconv.ParseBool(str3)
	fmt.Printf("b1 type %T b1=%v\n",b1,b1) // str type string str="23"
}
----

[IMPORTANT]
====
转换时需要确保能转换为有效值
====

[[go-getting-started-operator]]
== 运算符

[[go-getting-started-operator-base]]
=== 基本介绍

运算符用于在程序运行时执行数学或逻辑运算。

Go 语言内置的运算符有：

* 算术运算符
* 关系运算符
* 逻辑运算符
* 位运算符
* 赋值运算符
* 其他运算符

[NOTE]
====
Golang 语言明确不支持 三元运算符。如果需要实现三元运算的效果，如下

[source,go]
----
if expr{
	n = trueVal
} else {
	n = falseVal
}
----
====

接下来让我们来详细看看各个运算符的介绍

[[go-getting-started-operator-arithmetic]]
=== 算术运算符

下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20

[[go-getting-started-operator-arithmetic-tbl]]
.算术运算符
|===
| 运算符 | 描述 | 实例

| +	 |相加	| A + B 输出结果 30

| -	 | 相减	| A - B 输出结果 -10

| *	 | 相乘	| A * B 输出结果 200

| /	 | 相除	| B / A 输出结果 2

| %	 | 求余	| B % A 输出结果 0

| {plus}{plus} | 自增  | 	A{plus}{plus} 输出结果 11

| -- | 自减  | 	A-- 输出结果 9
|===

使用注意事项：

* 对于除号 "`/`" ，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。 例如 `x := 19/5` ,结果是 `3`
* 当对一个数取模时，可以等价 `a%b = a-a/b*b` ,这样我们可以看到取模的一个本质运算
* Golang 的自增和自减是语句，不是表达式，因此不能赋值给另外的变量，不能这样使用： `a = i++` ，`a =i --`
* Golang 的 `{plus}{plus}` 和 `--` 只能写在变量的后面，不能写在变量的前面。即，只有 `a{plus}{plus}`,`a--`，没有 `{plus}{plus}a`,`--a`

[[go-getting-started-operator-relationship]]
=== 关系运算符

关系运算符的结果都是 `bool`，也就是要么是 `true`，要么是 `false`.经常在 if 结构的条件中或循环结构的条件中。


下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。
[[go-getting-started-operator-relationship-tbl]]
.关系运算符
|===
| 运算符 | 描述 | 实例

| ==	 |检查两个值是否相等，如果相等返回 True 否则返回 False。	| (A == B) 为 False

| !=  | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。	| (A != B) 为 True

| >	 | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。	| (A > B) 为 False

| <	 | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。	| (A < B) 为 True

| <=	 | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。	| (A <= B) 为 True

| >= | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。  | (A >= B) 为 False
|===

[[go-getting-started-operator-logic]]
=== 逻辑运算符

下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。

[[go-getting-started-operator-logic-tbl]]
.逻辑运算符
|===
| 运算符 | 描述 | 实例

| &&   | 	逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。	| (A && B) 为 False

| {vbar}{vbar}  | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。| (A {vbar}{vbar} B) 为 True

| !	 | 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。| !(A && B) 为 True
|===

注意事项：

* && 也叫短路与：如果第一个条件为 `false`，则第二个条件不会判断。最终结果为 `false`
* || 也叫短路或：如果第一个条件为 `true`，则第二个条件不会判断，最终结果为 `true`

[[go-getting-started-operator-bitwise]]
=== 位运算符

位运算符对整数在内存中的二进制位进行操作。

下表列出了位运算符 `&`, `|`, 和 `^` 的计算：

[[go-getting-started-operator-bitwise-tbl]]
.位运算符
|===
|p	|q	|p & q	|p {vbar} q	|p ^ q

|0	|0	|0	|0	|0

|0	|1	|0	|1	|1

|1	|1	|1	|1	|0

|1	|0	|0	|1	|1
|===

Golang 语言支持的位运算符如下表所示。假定 A 为 60，B 为13：

[[go-getting-started-operator-bitwise-tbl2]]
.位运算符
|===
| 运算符 | 描述 | 实例

|&	| 按位与运算符 "&" 是双目运算符。 其功能是参与运算的两数各对应的二进位相与。	| (A & B) 结果为 12, 二进制为 0000 1100

|{vbar}	| 按位或运算符 "{vbar}" 是双目运算符。 其功能是参与运算的两数各对应的二进位相或	| (A {vbar} B) 结果为 61, 二进制为 0011 1101

|^	| 按位异或运算符 "^" 是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。	| (A ^ B) 结果为 49, 二进制为 0011 0001

|<<	| 左移运算符 "<<" 是双目运算符。左移n位就是乘以 2 的 n 次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由 "<<" 右边的数指定移动的位数，高位丢弃，低位补0。	| A << 2 结果为 240 ，二进制为 1111 0000

|>>	| 右移运算符 ">>" 是双目运算符。右移n位就是除以 2 的 n 次方。 其功能是把 ">>" 左边的运算数的各二进位全部右移若干位，">>" 右边的数指定移动的位数。	| A >> 2 结果为 15 ，二进制为 0000 1111
|===

[[go-getting-started-operator-assignment]]
=== 赋值运算符

下表列出了所有Go语言的赋值运算符。

[[go-getting-started-operator-assignment-tbl]]
.赋值运算符
|===
| 运算符 | 描述 | 实例

|=	| 简单的赋值运算符，将一个表达式的值赋给一个左值	 | C = A + B 将 A + B 表达式结果赋值给 C

|+=	| 相加后再赋值	| C += A 等于 C = C + A

|-=	| 相减后再赋值	| C -= A 等于 C = C - A

|*=	| 相乘后再赋值	| C *= A 等于 C = C * A

|/=	| 相除后再赋值	| C /= A 等于 C = C / A

|%=	| 求余后再赋值	| C %= A 等于 C = C % A

|<<=    | 左移赋值	| C <<= 2 等于 C = C << 2

|>>=	| 右移赋值	| C >>= 2 等于 C = C >> 2

|&=	| 位逻辑与赋值	| C &= 2 等于 C = C & 2

|^=	| 位逻辑或赋值	| C ^= 2 等于 C = C ^ 2

|{vbar}=	| 位逻辑异或赋值	| C {vbar}= 2 等于 C = C {vbar} 2
|===

注意事项：

* 运算顺序从右向左
* 赋值运算符的左边只能是 **变量** ，右边可以是 **变量，表达式，常量值**

[[go-getting-started-operator-other]]
=== 其他运算符

[[go-getting-started-operator-other-tbl]]
.其他运算符
|===
| 运算符 | 描述 | 实例

|&	| 返回变量存储地址		 | &a; 将给出变量的实际地址。

|*	| 指针变量。	| *a; 是一个指针变量
|===

[[go-getting-started-operator-level]]
=== 运算符的优先级

有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：

[[go-getting-started-operator-level-tbl]]
.运算符的优先级
|===
| 优先级    | 运算符

|7	| ^ !

|6	| * / % << >> & &^

|5	| + - {vbar} ^

|4	| == != < <= >= >

|3	| <-

|2	| &&

|1	| {vbar}{vbar}
|===

当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。

[[go-getting-started-flow]]
== 程序流程控制

在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，只要有三大流程控制语句

. 顺序控制
. 分支控制
. 循环控制

[[go-getting-started-order]]
=== 顺序控制

程序从上到西逐行执行，中间没有任何判断或跳转

[[go-getting-started-if]]
=== 分支控制

==== if 语句

关键字：`if`、`else`、`else` `if`

语法表达式:

[source,go,indent=0,subs="verbatim,quotes",role="primary"]
.单分支
----
if expre {
	// 执行代码块
}
----
.双分支
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
if expre {
	// 执行代码块1
} else {
    // 执行代码块2
}
----
.多分支
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
if expre1 {
	// 执行代码块1
} else if expre2 {
    // 执行代码块2
}
...
else {
    // 执行代码块n
}
----
.嵌套分支
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
if expre1 {
	if expre2{
	} else {

	}
}
----

if 语句使用注意事项

* 当 if 条件匹配后，会执行响应的代码块，执行完后退出 if，即使后面也有匹配的条件也不会执行
* if 的条件表达式只能是 bool 值，不能是赋值语句

[NOTE]
====
if 语句不需要()来包围条件语句，`{}` 为必须的，且必须与关键字同行
====

Golang 支持在 if 中，直接定义一个局部变量。比如：

[source,go]
----
if age:=20; age >18{
	fmt.Println("你的年龄大于18岁")
}
----

==== switch 语句

关键字：`switch`、`case`、`fallthrough`

语法格式:

====
[source,go]
----
switch i {                 //<1>
case 0:                    //<2>
      fmt.Printf("0")
case 1:                    //<3>
      fallthrough
case 2, 3:                 //<4>
      fmt.Printf("2,3,4")
default:                   //<5>
      fmt.Printf("Default")
}
----
<1>：`{` 须与 switch 同行,这里可以有一个初始化表达式，右侧需要跟分号
<2>：不需要明确的 break 来退出，默认自动退出
<3>：当 i=1 时输出 2,3，fallthrough 关键字会继续执行紧跟的下一个 case 代码
<4>：可以一个 case 中写多个满足条件（i 为 2，3 中的一个即可）
<5>：以上的都不匹配时执行
====

switch 后面的表达式不是必需的,这种结构与多个if...else if的逻辑作用等同

====
[source,go]
----
switch {                   //<1>
case 0 == i:
  fmt.Printf("0")
case 1 == i:
  fallthrough
case 2 == i || 3 == i:
  fmt.Printf("2,3,4")
default:
  fmt.Printf("Default")
}
----
<1>：`{` 这里可以有一个初始化表达式，右侧需要跟分号,如本行可写为switch i := 0; {
====

switch 使用注意事项

* case/switch 后是一个表达式(即：常量值，变量，一个有返回值的函数等都可以)
* case 后的各个表达式的值的数据类型，必须和 switch 的表达式数据类型一致
* case 后面可以带多个表达式，使用逗号间隔
* case 后面的表达式如果是常量，则要求不能重复
* case 后面不需要带 break，程序匹配到一个 case 后会执行对应的代码块，然后退出 switch，如果一个都匹配不到，则执行 default
* default 语句不是必须的
* switch 后也可以不带表达式，类似 if-else 分支来使用
* switch 后也可以直接声明/定义一个变量，分号结束。
* switch 穿透 fallthrough，如果在 case 语句块后增加 fallthrough，则会继续执行下一个 case，也叫 switch 穿透
* Type Switch：switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际指向的变量类型

[[go-getting-started-loop]]
=== 循环控制

==== for 语句

关键字：`for`、`range`、`break`、`continue`

基本语法

[source,go]
----
for 循环变量初始化;循环条件;循环变量迭代{
	循环操作(语句)
}
----

for 语句的多种格式

格式1：

====
[source,go]
----
package main

import (
	"fmt"
)

func main(){

	for i := 0;i < 10;i++{ <1>
		fmt.Println("Hello World",i)
	}
}
----
<1> 不需要 `()` 来包围条件语句，`{}` 为必须有的，且 `{` 必须与关键字同行
====

格式2：

====
[source,go]
----
k := 1

for { <1>
    if k <= 10 {
        fmt.Println("Hello World",k)
    } else {
        break
    }
    k++
}
----
<1> 类似于 Java 中的 `while(true)` 写法，是一个无限循环，通常需要配合 `break` 使用
====

格式3：

====
[source,go]
----
j := 0

for j <= 10 {
    fmt.Println("Hello World",j)
    j++
}
----
====

格式4：Golang 提供 for-range 的方式，可以方便的遍历字符串和数组

====
[source,go]
----
mySlice := []int{1, 2, 3, 4}              //<1>
sum := 0
for i, l := 0, len(mySlice); i < l; i++ { //<2>
    sum += mySlice[i]
}
----
<1> 定义一个slice
<2> 赋值语句支持多重赋值（仅支持平行多重赋值）
====

或者使用下面这种方式

====
[source,go]
----
for _, v := range mySlice {               // <1>
  sum += v                             // <2>
          //sum +=mySlice[i]
}
----
<1> range有两个返回值，i为索引，v为值。当对 map(后面讲解)进行遍历时，range的返回值分别为key,value
<2> 这里要注意 i 没有使用，编译错误，请使用 `_` 代替
====

==== while 和 do..while 的实现

Golang 语言没有 while 和 do..while 语法，可以通过 for 循环来实现其使用效果

while 的实现

[source,go]
----
package main

import (
	"fmt"
)

func main(){

	var i int = 1

	for {
		if i > 10 {
			break
		}
		fmt.Println("Hello World",i)
		i++
	}
	fmt.Println("i=",i) // 11
}
----

do..while 实现

[source,go]
----
package main

import (
	"fmt"
)

func main(){

	var i int = 1

	for {
		fmt.Println("Hello World",i)
		i++
		if i > 10 {
			break
		}
	}
	fmt.Println("i=",i)
}
----

==== 跳转语句

关键字: `goto` ，其实 `break` 及 `continue` 也有跳转的功能

三个语法都可以配合标签使用，标签区分大小写

[source,go]
----
label1:
for {
    if i > 10 {
        break label1
    }
    fmt.Println("Hello World",i)
    i++
}
fmt.Println("i=",i)
----

* goto     标签名：调整程序执行位置，标签可以在语句之后定义
* break    标签名：结束与标签同级的 for 循环,标签必须在语句之前定义
* continue 标签名：结束与标签同级的 for 循环,标签必须在语句之前定义

[[go-getting-started-infunction]]
== 内建函数

Golang 预定义了少数函数，这意味着无需引用任何包就可以使用他们，这些内建函数的文档记录在与 Go 版本一起发布的伪包 builtin 中。下表列出来所有的内建函数

[[go-getting-started-infunction-tbl]]
.内建函数
|===
| 函数名 | 描述

| func append(slice []Type, elems ...Type) []Type | 用于追加 slice

| func cap(v Type) int  |   cap 内建函数返回 v 的容量，这取决于具体类型

| func close(c chan<- Type) |   用于 channel 通信，使用它来关闭 channel

| func complex(r, i FloatType) ComplexType  |   complex 内建函数将两个浮点数值构造成一个复数值。 其实部和虚部的大小必须相同

| func copy(dst, src []Type) int    |   copy 内建函数将元素从来源切片复制到目标切片中

| func delete(m map[Type]Type1, key Type) | delete 内建函数按照指定的键将元素从映射中删除。 若 m 为 nil 或无此元素，delete 即为空操作

| func imag(c ComplexType) FloatType    |   imag 内建函数返回复数 c 的虚部

| func len(v Type) int  |   len 内建函数返回 v 的长度，这取决于具体类型

| func make(Type, size IntegerType) Type    | make 内建函数分配并初始化一个类型为切片、映射、或（仅仅为）信道的对象

| func new(Type) *Type | new 内建函数分配内存

| func panic(v interface{}) | 用于异常处理机制

| func print(args ...Type)  |   底层打印函数

| func println(args ...Type)    | 底层打印函数

| func real(c ComplexType) FloatType    | real 内建函数返回复数 c 的实部。

| func recover() interface{} | 用于异常处理机制
|===

关于这些内建函数的详情请参考官方文档 https://golang.org/pkg/builtin/[https://golang.org/pkg/builtin/] 或 中文文档 http://docscn.studygolang.com/pkg/builtin/#append[http://docscn.studygolang.com/pkg/builtin/#append]
