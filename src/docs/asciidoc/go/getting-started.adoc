[[go-getting-started]]
= 入门

[[go-getting-started-install]]
== 安装

具体安装教程参考下面链接

https://go-zh.org/doc/install[https://go-zh.org/doc/install]

GOROOT:GOROOT就是 go 的安装路径

GOPATH:是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。

GOPATH之下主要包含三个目录:

* bin:主要存放可执行文件;
* pkg:存放编译好的库文件,主要是*.a文件
* src:主要存放go的源文件

[IMPORTANT]
====
不要把 GOPATH 设置成 go 的安装路径,
可以自己在用户目录下面创建一个目录, 如 gopath
====

[[go-getting-started-hello-world]]
== Hello World

====
[source, go]
----
package main <1>

import "fmt" // 实现格式化的 I/O <2>

/* Print something */ <3>
func main() { <4>
	fmt.Printf("Hello World") <5>
}
----
<1> 首行这个是必须的。所有的 Go 文件以 package <something> 开头，对于独立运行的执行文件必须是 package main；
<2> 这是说需要将fmt 包加入 main。不是 main 的其他包都被称为库。末尾以 `//` 开头的内容是注释；
<3> 这同样是注释，不过这是被包裹于 `/*` 和 `*/` 之间的；
<4> package main 必须首先出现，紧跟着是 import。在 Go 中，package 总是首先出现，然后是 import，然后是其他所有内容。当 Go 程序在执行的时候，首先调用的函数 是 main.main()，这是从 C 中继承而来。这里定义了这个函数；
<5> 调用了来自于 fmt 包的函数打印字符串到屏幕。字符串由 `"` 包裹，并且可以包含非 ASCII 的字符。
====

[[go-getting-started-run]]
== 编译和运行代码

构建 go 程序的最佳途径是使用 go 工具,下面使用两种执行流程

=== 先编译，再执行
如上面的程序，要对其进行编译，只需要执行以下指令

[source, shell]
----
go build helloworld.go
----

构建的结果是 名为 helloworld 的可执行程序(windows 下是 `.exe` 文件，Linux 下是一个可执行文件)。然后运行

[source, shell]
----
./helloworld
----

=== 直接编译运行

或者我们可以直接使用 `go run` 命令编译运行，一步到位。

[source, shell]
----
go run helloworld.go
----

.两种执行流程的区别
****
* 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有 go 开发环境的机器上，仍然可以运行
* 如果使用 `go run` ，那么如果要在另外一台机器上使用，也需要 go 开发环境，否则无法执行
* 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所有，可执行文件大了许多
****

[[go-getting-started-notice]]
== 程序开发注意事项

. Go 源文件以 "go" 为扩展名
. Go 应用程序的执行入口是  main() 函数，这个是和其他编程语言(例如 java,c)一样。
. Go 语言严格区分大小写
. Go 方法由一条条语句构成，每个语句后面不需要分号(Go 语言会自动在每行后加分号)
. Go 编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一行，否则报错
. Go 语言定义的变量或者 import 的包如果没有使用到，代码不能编译通过
. 大括号都是成对出现的，不可省略

[[go-getting-started-specification]]
== Golang 代码规范

* Golang 官方推荐使用行注释来注释整个方法和语句
* 正确的缩进和空白，使用 gofmt 命令进行格式化
* 运算符两边习惯各加一个空格
* 大括号必须跟在语句后面，不能单起一行。
* 一行最多不超过80个字符

[[go-getting-started-guide]]
== Golang 官方编程指南

官方网站: https://tour.golang.org/list[https://tour.golang.org/list]
中文网站: http://go-tour-zh.appspot.com/list[http://go-tour-zh.appspot.com/list]

[[go-getting-started-escapes]]
== Golang 转义符

[[go-getting-started-escape-tbl]]
.常用转义符
|===
| 转移字符 | 描述

| \a
| 响铃

| \t
| 表示一个制表符，通常使用他排版

| \n
| 换行符

| \r
| 一个回车

| \b
| 退格

| \f
| 换页

| \v
| 垂直制表符

| \\
| 一个 \

| \"
| 一个 "

| \\
| 反斜杠
|===

[[go-getting-started-identifier]]
== Golang 标识符

Golang 对各种方法，函数，变量，自定义等命名时使用的字符序列称为标识符

标识符命名规则：

. 由 26 个英文字母大小写，0-9，_ 组成
. 数字不可以开头
. Golang 中严格区分大小写
. 标识符不能包含空格
. 下划线 `_` 本身在 Go 中是一个特殊的标识符，称为空标识符，可以代表任何其他的标识符，但是它对应的值会被忽略（比如，忽略某个返回值）。**所以仅能被作为占位符使用，不能作为标识符使用**
. 不能以系统<<go-getting-started-key>>作为标识符(25 个)

标识符命名注意事项

. 包名：保持 package 的名字和目录一致,尽量采取简短，有意义的包名，不要和标准库冲突
. 变量，函数，常量名采用驼峰式
. 如果变量名，函数名，常量名首字母大写，则可以被其他的包访问，如果首字母小写，只能在本包中使用


[[go-getting-started-key]]
== 系统保留关键字

25 个

[[go-getting-started-pre-identifier]]
== 系统预定义标识符

36 个


[[go-getting-started-vars]]
== 变量

与其他语言不同，在 go 语言中，变量的类型在变量名的后面。 例如，声明一个 `int` 类型的 a，是 a int , 而不是 int a.

当定义了一个变量，它默认赋值为其类型的 `null` 值，例如，在 var a int 后， `a` 的值为 `0`, 而 var s string ，`s` 为零长度字符串。也就是 `""`

在 Go 中，声明和初始化是两个过程,但是可以连在一起。以下实例显示了变量的使用方式

[[go-getting-started-vars-define]]
=== 变量的声明

* 基本语言 `var 变量名 数据类型`

变量在未进行初始化前，使用 <<go-getting-started-data-type-default>>
[source, go]
----
package main

import "fmt"

func main(){
	var i int
	fmt.Print("i=",i) //打印结果为 0
}
----

[[go-getting-started-vars-initialization]]
=== 初始化变量

在声明变量的时候就给值，则为初始化变量。可以省略数据类型

* 根据值自行判断类型

[source, go]
----
package main

import "fmt"

func main(){
	var i = 10
	fmt.Print("i=",i)
}
----

* 省略 `var` 也称为 短声明变量, 使用 `:=` 替代 `var` 。 注意，左侧的变量不应该是已经声明过的，且 `:` 不可以省略

[source, go]
----
package main

import "fmt"

func main(){
	i := 10
	fmt.Print("i=",i)
}
----

* 多变量声明

[source, go]
----
package main

import "fmt"

func main(){
	//变量类型一致
	var n1,n2,n3 int
	//变量类型不一致
	var n4,n5,n6 = 100,"tom",666
	//类型推导
	n7,n8,n9 := 200,"cheery",999

	fmt.Println("n1=",n1,"n2=",n2,"n3=",n3)
	fmt.Println("n4=",n4,"n5=",n5,"n6=",n6)
	fmt.Println("n7=",n7,"n8=",n8,"n9=",n9)
}
----

* 一次性声明,使用 `()`

[source,go]
----
package main

import "fmt"

var (
	name = "tom"
	age = 19
)

func main(){

	fmt.Println("name=",name,"age=",age)
}
----

一个特殊的变量名是 `_`（下划线）。下划线意思是忽略这个变量，例如，`f,err := os.Open(xxxxxxx)` 如果此时不需要知道返回的错误值，就可以用 `f, _ := os.Open(xxxxxx)` ,//如此则忽略了error变量。

[[go-getting-started-vars-assignment]]
=== 给变量赋值

在变量声明之后,再赋予变量的值，比如你先声明了变量: `var num int` ,默认为 `0` . 然后，再给值 `num = 100` 。这就是给变量赋值

[[go-getting-started-data-type]]
== 数据类型

Go 中的数据类型主要分为两大块，一块是基本数据类型，一块是复杂数据类型。每一种数据类型都定义了明确的数据类型，在内存中分配了不同大小的内存空间

[[go-getting-started-data-type-base]]
=== 基本数据类型

[[go-getting-started-data-type-base-int]]
==== 整型

当定义了整型类型而没有指定数据类型时，默认使用 `int` 类型

[[go-getting-started-data-type-base-int-tbl]]
.整型类型
|===
| 类型名称 | 有无符号 | 占用存储空间(bit) | 范围 | 备注

| int8	| Yes	| 8 | -128 ~ 127 |

| int16	| Yes	| 16 | -2{caret}15 ~ 2{caret}15-1 |

| int32	| Yes	| 32 | -2^31 ~ 2^31-1 |

| int64	| Yes	| 64 | -2^63 ~ 2^63-1|

| uint8	| No	| 8 | 0 ~ 255 |

| uint16	| No	| 16 | 0 ~ 2^16-1  |

| uint32	| No	| 32 | 0 ~ 2^32-1 |

| uint64	| No	| 64 | 0 ~ 2^64-1 |

| int	| Yes	| 等于cpu位数(32 为系统 4 个字节，64 位系统 8 个字节) |  32 位: -2^31 ~ 2^31-1 64 位: -2^63 ~ 2^63-1 |

| uint	| No	| 等于cpu位数(32 为系统 4 个字节，64 位系统 8 个字节) | 32 位: 0 ~ 2^64-1 64 位: 0 ~ 2^64-1|

| rune	| Yes	| 与 int32 等价 |  -2^31 ~ 2^31-1 | 表示一个 Unicode 码

| byte	| No	| 与 uint8 等价 | 0~255 | 当要存储字符时，选用 byte

| uintptr	| No	| - | |
|===

`rune` 类型是 `Unicode` 字符类型，和 `int32` 类型等价，通常用于表示一个 `Unicode` 码点。`rune` 和 `int32` 可以互换使用。

`byte` 是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是 一个小的整数。

`uintptr` 是一种无符号的整数类型，没有指定具体的bit大小但是足以容纳指针。 `uintptr` 类型只有在底层编程是才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方。

不管它们的具体大小，`int`、`uint` 和 `uintptr` 是不同类型的兄弟类型。其中 `int` 和 `int32` 也是 不同的类型， 即使 `int` 的大小也是 32bit，在需要将 `int` 当作 `int32` 类型的地方需要一个显式 的类型转换操作，反之亦然。

有符号整数采用 `2` 的补码形式表示，也就是最高 bit 位用作表示符号位，一个 `n` bit 的有 符号数的值域是从 `-2^{n-1}` 到 `2^{n-1}−1`。例如，`int8` 类型整数的值域是从 `-128` 到 `127`， 而 `uint8` 类型整数的值域是从 `0` 到 `255`。

[[go-getting-started-data-type-base-float]]
==== 浮点类型

Golang 的浮点型默认声明为 `float64` 类型

[[go-getting-started-data-type-base-float-tbl]]
.浮点类型
|===
| 类型名称  | 占用存储空间(bit) | 范围 | 备注

| 单精度 float32 | 32 | -3.403E38 ~ 3.403E38 |

| 双精度 float64 | 64 | -1.798E308 ~ 1.798E308 |
|===

说明

* 浮点数在机器中存放的形式：浮点数=符号位+指数位+尾位数
* 浮点数是有符号的
* 尾数部分可能丢失，造成精度损失(一个 `float32` 类型的浮点数可以提供大约 `6` 个十进制数的精度，而 `float64` 则可以提供约 `15` 个十进制数的精度).

[[go-getting-started-data-type-base-byte]]
==== 字符类型

Golang 中没有专门的字符类型，如果要存储单个字符（字母），一般使用 `byte` 存储

[NOTE]
====
字符串就是一串固定长度的字符连接起来的字符序列，Go 的字符串是有单个字节连接起来的，也就是说对于传统的字符串是由 **字符** 组成的，而在 Go 中是由 **字节** 组成的
====

====
[source,go]
----
package main

import "fmt"

func main(){
	var c1 byte = 'a'
	var c2 byte = '0'
	var c3 int = '北'
	//当直接输出 byte 值，就是输出了对应字符的 码值
	fmt.Println("c1=",c1," c2=",c2) <1>

	// 如果需要输出对应字符，需要格式化输出
	fmt.Printf("c1=%c c2=%c\n",c1,c2) <2>

	// var c3 byte = '北' // overflow 溢出
	fmt.Printf("c3=%c c3对应的码值=%d",c3,c3) <3>
}
----
<1> 当直接输出 byte 值，就是输出了对应字符的 码值,输出结果为: c1=97 c2=48
<2> 如果需要输出对应字符，需要格式化输出,输出结果为: c1=a c2=0
<3> 如果我们保存的字符在 ASCII 表，比如[0-1,a-z,A-Z] 则可以直接保存到 `byte`。如果保存的字符对应的码值大于 `255` ，这时可以考虑使用 `int` 类型保存.输出结果为:c3=北 c3对应的码值=21271
====

字符串使用细节

* 字符常量使用单引号括(`''`)起来的单个字符。
* Go 中允许使用转义字符 `\` 来将其后的字符转变为特殊字符型常量。例如: var c2 byte = '\n' \n 表示换行符
* Go 语言的字符使用 UTF-8 编码，可以在 http://www.mytju.com/classcode/tools/encode_utf8.asp[这个网站] 查询字符对应的 UTF-8 码值
* 在 Go 中，字符的本质是一个整数，直接输出时，是该字符对应的 UTF-8 编码的码值
* 可以直接给某一个变量赋一个数字，然后使用 `%c` 格式化输出，会输出该数字对应的 unicode 值
* 字符类型可以进行运算，运算时是按照码值进行运算的

[[go-getting-started-data-type-base-bool]]
==== 布尔型

布尔类型也叫 bool 类型，bool 类型只允许取值 `true` 或 `false`,bool 类型占用一个字节

`if` 和 `for` 语句的条件部分都是布尔类型的值，并且 `==` 和 `<` 等比 较操作也会产生布尔型的值。一元操作符 `!` 对应逻辑非操作，因此 `!true` 的值为 `false`。

布尔值可以和 `&&`（AND）和 `||（OR）` 操作符结合，并且可能会有短路行为：如果运算符左边值已经可以确 定整个布尔表达式的值，那么运算符右边的值将不在被求值

布尔值并不会隐式转换为数字值 `0` 或 `1`，反之亦然。必须使用一个显式的 `if` 语句辅助转换。

[[go-getting-started-data-type-base-plural]]
==== 复数

Go语言提供了两种精度的复数类型：`complex64` 和 `complex128`，分别对应 `float32` 和 `float64` 两种浮点数精度。内置的 `complex` 函数用于构建复数，内建的 `real` 和 `imag` 函数分别返回复数的实部和虚部。

复数也可以用 `==` 和 `!=` 进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。 `math/cmplx` 包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。

[source,go]
----
z := x + yi
x = real(z)
y = imag(z)
----

[[go-getting-started-data-type-base-string]]
==== 字符串

Go 语言的字符串是由单个字节连接起来的，Go 语言的字符串的字节使用 UTF-8 编码标识的 Unicode 文本

**Go 语言中的字符串是不可变的**

字符串的两种表现形式

* 双引号：会识别转义字符
* 反引号：以字符串的原生形式输出，包括换行和特殊字符

[[go-getting-started-data-type-complex]]
=== 复杂数据类型

[[go-getting-started-data-type-complex-pointer]]
==== 指针

指针（pointer）在Go语言中可以被拆分为两个核心概念：

* 指针类型，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。
* 切片，由指向起始元素的原始指针、元素数量和容量组成。

===== 指针地址和指针类型

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go 语言中使用在变量名前面添加 `&` 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：

[source,go]
----
ptr := &v    // v 的类型为 T
----

其中 `v` 代表被取地址的变量，变量 `v` 的地址使用变量 `ptr` 进行接收，`ptr` 的类型为 `{asterisk}T`，称做 `T` 的指针类型，`{asterisk}` 代表指针。

====
[source,go]
----
package main
import (
    "fmt"
)
func main() {
    var cat int = 1 <1>
    var str string = "banana" <2>
    fmt.Printf("%p %p", &cat, &str) //0xc042052088 0xc0420461b0 <3>
}
----
<1> 声明整型变量 cat。
<2> 声明字符串变量 str。
<3> 使用 fmt.Printf 的动词%p打印 cat 和 str 变量的内存地址，指针的值是带有 0x 十六进制前缀的一组数据。
====

[TIP]
====
变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。
====

===== 从指针获取指针指向的值

当使用 `&` 操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用 `*` 操作符，也就是指针取值，代码如下。

====
[source,go]
----
package main
import (
    "fmt"
)
func main() {
    // 准备一个字符串类型
    var house = "Malibu Point 10880, 90265" <1>
    // 对字符串取地址, ptr类型为*string
    ptr := &house <2>
    // 打印ptr的类型
    fmt.Printf("ptr type: %T\n", ptr) // ptr type: *string <3>
    // 打印ptr的指针地址
    fmt.Printf("address: %p\n", ptr) // address: 0xc0420401b0 <4>
    // 对指针进行取值操作
    value := *ptr <5>
    // 取值后的类型
    fmt.Printf("value type: %T\n", value) // value type: string <6>
    // 指针取值后就是指向变量的值
    fmt.Printf("value: %s\n", value) // value: Malibu Point 10880, 90265 <7>
}
----
<1> 准备一个字符串并赋值。
<2> 对字符串取地址，将指针保存到变量 ptr 中。
<3> 打印变量 ptr 的类型，其类型为 *string。
<4> 打印 ptr 的指针地址，地址每次运行都会发生变化。
<5> 对 ptr 指针变量进行取值操作，变量 value 的类型为 string。
<6> 打印取值后 value 的类型。
<7> 打印 value 的值。
====

取地址操作符 `&` 和取值操作符 `{asterisk}` 是一对互补操作符，`&` 取出地址，`{asterisk}` 根据地址取出地址指向的值。

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

* 对变量进行取地址操作使用 `&` 操作符，可以获得这个变量的指针变量。
* 指针变量的值是指针地址。
* 对指针变量进行取值操作使用 {asterisk} 操作符，可以获得指针变量指向的原变量的值。

===== 使用指针修改值

通过指针不仅可以取值，也可以修改值。

前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：

====
[source,go]
----
package main
import "fmt"
// 交换函数
func swap(a, b *int) { <1>
    // 取a指针的值, 赋给临时变量t
    t := *a <2>
    // 取b指针的值, 赋给a指针指向的变量
    *a = *b <3>
    // 将a指针的值赋给b指针指向的变量
    *b = t <4>
}
func main() {
// 准备两个变量, 赋值1和2
    x, y := 1, 2 <5>
    // 交换变量值
    swap(&x, &y) <6>
    // 输出变量值
    fmt.Println(x, y) // 2 1 <7>
}
----
<1> 定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。
<2> 取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。
<3> 取 b 的指针值，赋给指针 a 指向的变量。注意，此时*a的意思不是取 a 指针的值，而是“a 指向的变量”。
<4> 将 t 的值赋给指针 b 指向的变量。
<5> 准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。
<6> 取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。
<7> 交换完毕时，输出 x 和 y 的值。
====

`{asterisk}` 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，`{asterisk}` 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。

如果在 `swap()` 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：

[source,go]
----
package main
import "fmt"
func swap(a, b *int) {
    b, a = a, b
}
func main() {
    x, y := 1, 2
    swap(&x, &y)
    fmt.Println(x, y) // 1 2
}
----

结果表明，交换是不成功的。上面代码中的 `swap()` 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。

.创建指针的方法
****
Go语言还提供了另外一种方法来创建指针变量，格式如下：

new(类型)

一般这样写：

[source,go]
----
str := new(string)
*str = "Go语言教程"
fmt.Println(*str)
----
****

[[go-getting-started-data-type-default]]
=== 零值(默认值)

[[go-getting-started-data-type-default-tbl]]
.零值
|===
| 数据类型 | 默认值

| 整型
| 0

| 浮点型
| 0

| 字符串
| ""

| 布尔类型
| false
|===

[[go-getting-started-data-type-convert]]
=== 数据类型转换

Golang 和 java/c 不同，Go 在不同类型的变量之间赋值时需要显示转换。也就是说 Golang 中数据类型不能自动转换

==== 基本数据类型转换

表达式 T(v) 将值 v 转换为类型 T

T : 就是数据类型,比如 int32,int64,float32
v: 就是需要转换的变量

====
[source,go]
----
package main

import (
	"fmt"
)
func main()  {
	var n1 int32 = 100

	var n2 float32 = float32(n1) <1>

	var n3 int8 = int8(n1) <2>

	var n4 int64 = int64(n1) <3>

	fmt.Printf("n1=%v n2=%v n3=%v n4=%v",n1,n2,n3,n4)
}
----
<1> 将 n1 转换为 float32 类型
<2> 将 n1 转换为 int8 类型
<3> 将 n1 转换为 int64 类型
====

[NOTE]
====
* 被转换的是变量存储的数据（即值），变量本身的数据类型并没有变化！
* 在转换中，比如将 int64 转为 int8 ，编译时不会报错，只是转化结果按溢出处理。因此在转换时，需要考虑范围
====

==== 基本数据类型转 string 类型

* func Sprintf(format string, a ...interface{}) string

[source,go]
----
package main

import "fmt"

func main(){
	var num int = 0
	var num2 float64 = 23.456
	var b bool = true
	var mychar byte = 'h'
	var str string

	str = fmt.Sprintf("%d",num)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="0"

	str = fmt.Sprintf("%f",num2)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="23.456000"

	str = fmt.Sprintf("%t",b)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="true"

	str = fmt.Sprintf("%c",mychar)
	fmt.Printf("str type %T str=%q\n",str,str) //str type string str="h"
}
----

* 使用 strconv 包的函数

[source,go]
----
package main

import (
	"fmt"
	"strconv"
)

func main(){
	var num3 int = 23
	var num4 float64 = 23.456
	var b2 bool = true
	var str string

	str = strconv.FormatInt(int64(num3),10)
	fmt.Printf("str type %T str=%q\n",str,str) // str type string str="23"

	str = strconv.FormatFloat(num4,'f',10,64)
	fmt.Printf("str type %T str=%q\n",str,str) // str type string str="23.4560000000"

	str = strconv.FormatBool(b2)
	fmt.Printf("str type %T str=%q\n",str,str) // str type string str="true"
}
----

====  string 类型转基本数据类型

* 使用 strconv 包的函数

[source,go]
----
package main

import (
	"fmt"
	"strconv"
)

func main(){

	var str1 string = "64"
	var str2 string = "25.3664"
	var str3 string = "false"
	// strconv.ParseInt 返回值为 int 64,如果需要得到 int 8

	num1,_ := strconv.ParseInt(str1,10,32)
	fmt.Printf("num1 type %T num1=%v\n",num1,num1) // str type string str="23"

	f1,_ := strconv.ParseFloat(str2,10)
	fmt.Printf("f1 type %T f1=%v\n",f1,f1) // str type string str="23"

	b1,_ := strconv.ParseBool(str3)
	fmt.Printf("b1 type %T b1=%v\n",b1,b1) // str type string str="23"
}
----

[IMPORTANT]
====
转换时需要确保能转换为有效值
====

