[[go-function]]
= 函数

为完成某一功能的程序指令(语句)的集合,称为函数.函数是构建 Go 程序的基础部件

====
[source,go]
----
func (p mytype) funcname(q int) (r,s int) {
	//执行语句
	return 0,0
}
----
* 关键字 `func` 用于定义一个函数
* 函数可以绑定到特定的类型上,这叫做接受者,有接受者的函数被称为 `method`
* funcname 是函数的名字
* 形式参数,表示函数的输入.这里是 int 类型的变量 q 作为输入.参数用 `pass-by-value` 方式传递,意味着他们会被复制
* 函数返回值.函数可以有多个返回值,也可以没有返回值.当只有一个返回值时,`()` 可以省略.如果没有返回值,也可以省略这些内容
* 函数体.注意 return 是一个语句,所以包裹参数的括号是可选的
====

[[go-function-invoke]]
== 函数调用过程

. 在调用一个函数时,会给该函数分配一个新的空间,编译器会通过自身的处理让这个新的空间和其他的栈的空间区分开来
. 在每个函数对应的栈中,数据空间是独立的,不会混淆
. 当一个函数调用完毕后,程序会销毁这个函数对应的栈空间

[[go-function-scope]]
== 作用域

在 Go 中,定义在函数外的变量时全局的,那些定义在函数内部的变量,对于函数来说是局部的.如果命名覆盖,在函数执行的时候,局部变量将覆盖全局变量

image::{base-images}/go1.png[]

在上述左侧函数 q() 中定义了局部变量 a.局部变量 a 仅在 q() 中可见.打印结果为:656

在右侧中没有定义局部变量,只有全局变量 a.这将使得对 a 的赋值全局可见.打印结果为:655

[[go-function-use]]
== 函数的使用

[[go-function-use-return-value]]
=== 多返回值

Go 函数支持多个返回值,如下

[source,go]
----
package main

import (
	"fmt"
)

func main(){
	sum,sub := getSumAndSub(10,20)
	fmt.Printf("sum=%d,sub=%d \n",sum,sub)
}

func getSumAndSub(a,b int) (int,int){
	return a+b,a-b
}
----

希望忽略某个返回值,则使用 `_` 符号表示占位符

[source,go]
----
package main

import (
	"fmt"
)

func main(){
	_,sub := getSumAndSub(10,20)
	fmt.Printf("sub=%d \n",sub)
}

func getSumAndSub(a,b int) (int,int){
	return a+b,a-b
}
----

如果返回值只有一个,可以不写 `()`

[source,go]
----
func getSum(a,b int) int{
	return a+b
}
----

[[go-function-use-return-value-name]]
=== 命名返回值

Go 函数的返回值或者结果参数可以指定一个名字,并且像原始的变量那样使用,就像输入参数那样,如果对其命名,在函数开始时,它们会用其类型的<<go-getting-started-data-type-default>>初始化.

[source,go]
----
func getSumAndSub(a,b int) (sum int,sub int){
	sum = a + b
	sub = a - b
	return
}
----

[[go-function-use-params]]
=== 可变参数

接收不定数量的参数的函数叫做变参函数,定义函数使其接收变参

[source,go]
----
func myfunc(arg ...int){}
----

`arg ...int` 告诉 go 这个函数接受不定数量的参数.注意这些参数的类型都是 `int`.在函数体中,变量 arg 是一个 int 类型的 <<go-getting-started-data-type-complex-slice>>

[source,go]
----
func main(){
	res := sum(10,2,1,58,8)
	fmt.Printf("res=%d\n",res) //res=79
}
func sum(n1 int ,arg ...int) int{
	sum := n1
	for i := 0; i< len(arg); i++{
		sum += arg[i]
	}
	return sum
}
----

如果不指定变参的类型,默认是空接口 `interface{}`

[[go-function-use-defer]]
=== 延时机制(defer)

在函数中,程序员经常需要创建资源(比如,数据库连接,文件句柄,锁等),为了在函数执行完毕后及时释放资源.Go 的设计者提供 defer (延时机制)

[source,go]
----
func sum(n1 int,n2 int) int{
	defer fmt.Println("sum() n1=",n1)
	defer fmt.Println("sum() n2=",n2)
	res := n1 + n2
	fmt.Println("sum() res=",res)
	return res
}
func main(){
	res := sum(10,20)
	fmt.Println("res= ",res)
}

// 输出结果
// sum() res= 30
// sum() n2= 20
// sum() n1= 10
// res=  30
----

* 当 go 执行到一个 defer 时,不会立即执行 defer 后面的语句,而是将 defer 后的语句压入到一个栈中,然后继续执行函数的下一个语句
* 当函数执行完毕后,再从栈中,依次从栈顶中取出语句执行
* 在 defer 将语句放入到栈时,也会将相关的值拷贝同时入栈

defer 的主要价值在于当函数执行完成后,可以及时的释放函数创建的资源,请看以下代码:

[source,go]
----
func test(){
    file = openfile(文件名)
    defer file.close()
}
----

. 在 defer 后,可以继续使用创建资源
. 当函数执行完毕后,系统会依次从 defer 栈中取出语句,关闭资源
. 这种话你机制,非常简洁,程序员不用再为在什么时候关闭资源而烦恼了

[[go-function-use-panic-recover]]
=== 恐慌(Panic)和恢复(Recover)

Go 没有像 Java 那样的异常机制,例如你无法像在 Java 中那样抛出一个异常,作为替代,它使用了恐慌和恢复 (panic-and-recover) 机制.一定要记得,这应当作为最后的手段被使用,你的代码中应当没有,或者很少的令人恐慌
的东西.

Panic:是一个内建函数,可以中断原有的控制流程,进入一个令人恐慌的流程中.当函数 F 调用 `panic`,函数 F 的执行被中断,并且 F 中的延迟函数会正常执行,然后 F 返回到调用它的地方.在调用的地方,F 的行为就像调用了 `panic`.这一过
程继续向上,直到程序崩溃时的所有 `goroutine` 返回. 恐慌可以直接调用 `panic` 产生.也可以由运行时错误产生,例如访问越界的数组.

Recover:是一个内建的函数,可以让进入令人恐慌的流程中的 `goroutine` 恢复过来.`recover` 仅在延迟函数中有效.在正常的执行过程中,调用 `recover` 会返回 `nil` 并且没有其他任何效果.如果
当前的 `goroutine` 陷入恐慌,调用 `recover` 可以捕获到 `panic` 的输入值,并且恢复正常的执行.

以下这个函数检查作为其参数的函数在执行时是否会产生 panic

====
[source,go]
----
func throwsPanic(f func()) (b bool){ <1>
	defer func() { <2>
		if x := recover();x != nil {
			b = true
		}
	}()
	f() <3>
	return  <4>
}
----
<1> 定义一个 throwsPanic 函数接收一个函数作为参数.函数 `f` 产生 `panic`,就返回 `true`,否则返回 `false`
<2> 定义了一个利用 `recover` 的 `defer` 函数,如果当前的 `goroutine` 产生了 `panic`,这个 `defer` 函数能够发现.当 `recover()` 返回非 `nil` 值,设置 `b` 为 `true`
<3> 调用作为参数接收的函数
<4> 返回 `b` 的值.由于 `b` 是命名返回
====

简单来说,在 Go 中可以抛出一个 `panic` 异常,然后在 `defer` 中通过 `recover` 捕获这个异常,然后正常处理,看下面的例子

====
.使用 defer 和 recover 来处理错误
[source,go]
----
package main

import (
	"fmt"
	"time"
)

func test(){
	defer func(){
		err := recover() <1>
		if err != nil { <2>
			fmt.Println("err=",err)
		}
	}()

	num1 := 10
	num2 := 0
	res := num1 / num2
	fmt.Println("res=",res)
}

func main(){
	test()
	for {
		fmt.Println("main() 下面的代码")
		time.Sleep(time.Second)
	}
}
----
<1> recover 内置函数,可以捕获到异常
<2> 说明捕获到错误
====

==== 自定义错误处理

Go 程序中,也支持自定义错误,使用 errors.New 和 panic 内置函数

. errors.New("错误说明"),会返回一个 error 类型的值,表示一个错误
. panic 内置函数,接收一个 interface{} 类型的值(也就是任何值)作为参数,可以接收 error 类型的变量,输出错误信息,退出程序

看下面的例子

====
[source,go]
----
package main

import (
	"errors"
	"fmt"
)

func readconf(name string) (err error){ <1>
	if name == "myconf.ini" {
		return nil
	} else {
		return errors.New("读取文件错误") <2>
	}
}

func main(){
	err := readconf("mycof.ini")
	if err != nil {
		panic(err) <3>
	}
	fmt.Println("程序继续执行")
}
----
<1> 定义一个函数读取配置文件信息,如果配置文件名不正确,我们就返回一个自定义错误
<2> 返回一个自定义错误
<3> 如果读取文件发生错误,就输出这个错误,并终止程序
====

[[go-function-use-init]]
=== init 函数

每一个源文件都可以包含一个 init 函数,该函数会在 main 函数之前执行.被 Go 运行框架调用,也就是说 init 会在 main 函数之前被调用

[source,go]
----
package main

import (
	"fmt"
)

func init(){
	fmt.Println("init()...")
}
func main(){
	fmt.Println("main()....")
}
// 输出结果
// init()...
// main()....
----

. 如果一个文件同时包含全局变量定义,`init` 函数和 `main` 函数,则执行的流程 全局变量定义 -> `init` 函数 -> `main` 函数
. `init` 函数最主要的作用就是完成一些初始化的工作
. 如果本文件和被引入的文件中都包含变量的定义,先执行被引入包中变量的定义(被引入包变量定义 -> 被引入包 `init` 函数).然后在执行本文件的变量定义和 `init` 函数

[[go-function-use-anonymous]]
=== 匿名函数

Go 支持匿名函数,匿名函数就是没有名字的函数,如果我们某个函数只是希望调用一个,可以考虑使用匿名函数,匿名函数也可以多次调用

在定义匿名函数时就直接使用,这种方式匿名函数只能调用一次

[source,go]
----
package main

import (
	"fmt"
)

func main(){
	res1 := func(n1 int, n2 int) int{
		return n1 + n2
	}(10,20)

	fmt.Println("res1=",res1)// res1= 30
}
----

将匿名函数赋给一个全局变量,那么这个匿名函数,就成为一个全局匿名函数,可以在程序中有效

[source,go]
----
package main

import (
	"fmt"
)

var (
	Fun1 = func(n1 ,n2 int) int {
		return n1+n2
	}
)

func main(){
	res2 := Fun1(4,9)
	fmt.Println("res2=",res2) // res2= 13
}

----

[[go-function-use-close]]
=== 闭包

闭包就是一个函数和与其相关的引用环境组成的一个整体(实体).简单理解,闭包就是函数返回一个匿名函数,看一个例子:

====
[source,go]
----
package main

import (
	"fmt"
)

func AddUpper() func (int) int{ <1>
	var n = 10

	return func(x int) int { <2>
		n = n + x
		return n
	}
}

func main() {
	f := AddUpper()
	fmt.Println(f(1)) // 11
	fmt.Println(f(2)) // 13
	fmt.Println(f(3)) // 16
}
----
<1> AddUpper 是一个函数,返回值的类型 func (int) int
<2> 返回的是一个匿名函数,但是这个匿名函数引用到函数外的 n,因此这个匿名函数就和 n 形成一个整体,构成闭包
====

[[go-function-common]]
== 常用函数

[[go-function-common-string]]
=== 字符串常用函数

日期相关操作的函数位于 `strings` 包下,在使用是需要导入 `strings` 包

[[go-function-common-string-tbl]]
.字符串常用函数
|===
| 函数 | 说明

| len(str) | 按字节统计字符串的长度

| []rune(str) | 字符串遍历,同时处理有中文的问题

| func Atoi(s string) (int, error) | 字符串转整数

| func Itoa(i int) string | 整数转字符串

| []byte(str) | 字符串转[]byte

| string([]byte{}) | []byte 转字符串

| func FormatInt(i int64, base int) string | 10 进制转 2.8.16 进制

| func Contains(s, substr string) bool | 查找子串是否在指定的字符串中

| func Count(s, substr string) int | 统计一个字符串有几个指定的子串

| func EqualFold(s, t string) bool | 不区分大小写的字符串比较

| func Index(s, substr string) int  | 返回子串在指定字符串第一次出现的 `index` 值,如果没有,返回 `-1`

| func LastIndex(s, substr string) int  | 返回子串在指定字符串最后一次出现的 `index` 值,如果没有,返回 `-1`

| func Replace(s, old, new string, n int) string  | 将指定的子串替换成另一个子串

| func Split(s, sep string) []string  | 按照指定的字符将指定字符串拆分为字符串数组

| func ToLower(s string) string/func ToUpper(s string) string  | 将字符串的字母进行大小写转换

| func TrimSpace(s string) string  | 将字符串左右两边的空格去掉

| func Trim(s string, cutset string) string  | 将字符串左右两边指定的字符去掉

| func TrimLeft(s string, cutset string) string  | 将字符串左边指定的字符去掉

| func TrimRight(s string, cutset string) string  | 将字符串右边指定的字符去掉

| func HasPrefix(s, prefix string) bool  | 判断字符串是否以指定的字符串开头

| func HasSuffix(s, suffix string) bool  | 判断字符串是否以指定的字符串结束
|===

[[go-function-common-date]]
=== 日期常用函数

日期相关操作的函数位于 `time` 包下,在使用是需要导入 `time` 包

`time` 包中关于时间的常量

[source,go]
----
const (
	Nanosecond  Duration = 1
	Microsecond          = 1000 * Nanosecond
	Millisecond          = 1000 * Microsecond
	Second               = 1000 * Millisecond
	Minute               = 60 * Second
	Hour                 = 60 * Minute
)
----

[[go-function-common-date-tbl]]
.日期常用函数
|===
| 函数 | 说明

| func Now() Time | 获取当前时间

| func (t Time) Year() int | 获取年份

| func (t Time) Month() Month | 获取月份

| func (t Time) Day() int | 获取天

| func (t Time) Weekday() Weekday | 获取周

| func (t Time) Hour() int | 获取时

| func (t Time) Minute() int | 获取分

| func (t Time) Second() int | 获取秒

| func (t Time) Nanosecond() int | 获取纳秒

| Printf 或 Sprintf | 格式化日期

| func Sleep(d Duration) | 休眠

| func (t Time) Unix() int64 | time 的 Unix 时间

| func (t Time) UnixNano() int64 | time 的 UnixNano 时间
|===

[[go-function-infunction]]
== 内建函数

Golang 预定义了少数函数,这意味着无需引用任何包就可以使用他们,这些内建函数的文档记录在与 Go 版本一起发布的伪包 builtin 中.下表列出来所有的内建函数

[[go-function-infunction-tbl]]
.内建函数
|===
| 函数名 | 描述

| func append(slice []Type, elems ...Type) []Type | 用于追加 slice

| func cap(v Type) int  |   cap 内建函数返回 v 的容量,这取决于具体类型

| func close(c chan<- Type) |   用于 channel 通信,使用它来关闭 channel

| func complex(r, i FloatType) ComplexType  |   complex 内建函数将两个浮点数值构造成一个复数值. 其实部和虚部的大小必须相同

| func copy(dst, src []Type) int    |   copy 内建函数将元素从来源切片复制到目标切片中

| func delete(m map[Type]Type1, key Type) | delete 内建函数按照指定的键将元素从映射中删除. 若 m 为 nil 或无此元素,delete 即为空操作

| func imag(c ComplexType) FloatType    |   imag 内建函数返回复数 c 的虚部

| func len(v Type) int  |   len 内建函数返回 v 的长度,这取决于具体类型

| func make(Type, size IntegerType) Type    | make 内建函数分配并初始化一个类型为切片、映射、或(仅仅为)信道的对象

| func new(Type) *Type | new 内建函数分配内存

| func panic(v interface{}) | 用于异常处理机制

| func print(args ...Type)  |   底层打印函数

| func println(args ...Type)    | 底层打印函数

| func real(c ComplexType) FloatType    | real 内建函数返回复数 c 的实部.

| func recover() interface{} | 用于异常处理机制
|===

关于这些内建函数的详情请参考官方文档 https://golang.org/pkg/builtin/[https://golang.org/pkg/builtin/] 或 中文文档 http://docscn.studygolang.com/pkg/builtin/#append[http://docscn.studygolang.com/pkg/builtin/#append]

== 注意事项

. 函数的形参列表可以是多个,返回值列表也可以是多个
. 形参列表和返回值列表的数据类型可以是值类型和引用类型
. 函数的命名遵循<<go-getting-started-identifier>> 命名规范
. 首字母大写的函数可以被本包和其他包文件使用.首字母小写,只能被本包文件使用
. 函数中的变量时局部的,函数外不生效
. 基本数据类型和数组默认都是值传递的,即进行值拷贝.在函数内修改,不会影响到原来的值
. 如果希望函数内的变量能修改函数外的变量(指的是默认以值传递的方式的数据类型),可以传入变量的地址 `&` ,函数内以 <<go-getting-started-data-type-complex-pointer>> 的凡是操作变量
. Go 函数不支持函数重载
. 函数是一种数据类型,参见<<go-getting-started-data-type-complex-function,函数数据类型>>
. 使用 `_` 标识符,忽略返回值
