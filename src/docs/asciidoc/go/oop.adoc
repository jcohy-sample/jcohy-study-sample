[[go-oop]]
= 面向对象编程

Golang 也支持面向对象编程(OOP),但是和传统的面向对象编程有区别,并不是纯粹的面向对象语言.所有我们说 Golang 支持面向对象编程的特性

Golang 没有类(`class`) Go 语言的结构体 (`struct`) 和其他编程语言的类(`class`)有同等的地位,你可以理解 Golang 是基于 `struct` 来实现 OOP 特性的

Golang 面向对象编程非常简洁,去掉了传统 OOP 语言的集成,方法重载,构造函数和析构函数,隐藏的 `this` 指针等

Golang 仍然有面向对象编程的集成,封装和多态的特性,只是实现的方式和其他 OOP 语言不一样,比如,继承 Golang 没有 extends 关键字,继承是通过匿名字段来实现的

Golang 面向对象(OOP)很优雅,OOP 本身就是语言类型系统(type system)的一部分,通过接口 interface 关联,耦合性低,也很灵活.

在介绍 Golang 中的面向对象特性之前,先来认识两种新的数据类型 <<go-oop-struct>> 和 <<go-oop-interface>>

[[go-oop-struct]]
== 结构体(struct)

[[go-oop-struct-declare]]
=== 声明结构体

====
[source,go]
----
type 结构体名称 struct {
    field1 type <1>
    field2 type
}
----
<1> 字段声明语法同变量,字段类型可以为基本类型,数组或引用类型
====

在创建一个结构体后,如果没有给字段赋值,都对应一个 <<go-getting-started-data-type-default>>.数组类型的默认值和它的元素类型相关.

不同的结构体变量的字段是独立的,互不影响,一个结构体变量字段的更改,不影响另一个.**结构体是值类型**

[[go-oop-struct-use]]
=== 结构体的使用

我们通过一个简单的例子来介绍结构体的使用,首先先定义一个结构体

====
[source,go]
----
type Person struct {
	Name string <1>
	Age int
	Scpres [5]float64
	ptr *int <2>
	slice []int
	map1 map[string]string
}
----
<1> 字段名首字母大写才能被外部访问
<2> `指针`,`slice`,和 `map` 的零值都是 `nil`,如果使用这样的字段,需要先 `make` ,才能使用
====

. 直接声明
+
[source,go]
----
var person1 Person
----
. 使用 `{}` 声明,可以直接给字段赋值
+
[source,go]
----
var person2 Person = Person{}
----
. 使用 `&` 声明
+
[source,go]
----
var person3 *Person = new(Person)
----
因为 `person3` 是一个指针,因此标准的给字段赋值方式为: `(*person3).Name = "jcohy"` 也可以这么写 `person3.Name = "jcohy"` .Go 的设计者在底层会对 `person3.Name = "jcohy"` 进行处理,会给 person3 加上取值运算
. 使用 `&` 和 `{}`,可以直接给字段赋值
+
[source,go]
----
var person4 *Person = &Person{}
----
因为 `person4` 是一个指针,因此标准的给字段赋值方式为: `(*person4).Name = "jcohy"` 也可以这么写 `person4.Name = "jcohy"` .Go 的设计者在底层会对 `person4.Name = "jcohy"` 进行处理,会给 person4 加上取值运算

3 和 4 返回的是结构体指针,结构体指针访问字段的标准方式是 `(*结构体指针).字段名`,但也可以使用 `(结构体指针).字段名`.这是因为 go 编译器底层对 `(结构体指针).字段名` 做了转换

[[go-oop-struct-memory]]
=== 结构体的内存结构

[[go-oop-struct-notice]]
=== 注意事项

. 结构体的所有字段再内存中是连续的
. 结构体是用户单独定义的类型,和其他类型进行转换时需要有完全相同的字段(名字,个数个类型)
. 结构体进行 type 重新定义(相当于取别名),Golang 认为是新的数据类型,但是相互间可以强转
. struct 的每个字段上, 可以写上一个 tag,该 tag 可以通过反射机制获取,常见的使用场景就是序列化和反序列化
+
[source,go]
----
type Monster struct {
	Name string `json:"name"`
	Age int `json:"age"`
	Skill string `json:"skill"`
}

func main(){
	monster := Monster{"叶凡",20,"天帝拳"}
	jsonStr,err := json.Marshal(monster)
	if err != nil {
		fmt.Println("json 处理错误",err)
	}
	fmt.Println("jsonStr", string(jsonStr)) //jsonStr {"name":"叶凡","age":20,"skill":"天帝拳"}
}
----

[[go-oop-struct-method]]
=== 结构体方法

在某些情况下,我们需要声明(定义)方法.比如 Person 结构体中,除了有一些字段外,还有一些行为,例如说话,跑步等.

Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定),因为自定义类型都可以有方法,而不仅仅是 `struct`

[[go-oop-struct-method-declare]]
==== 方法声明(定义)

方法就是有接受者的函数

====
[source,go]
----
func (recevier type) methodName(参数列表) (返回值列表){
	方法体
	return 返回值
}
----
参数列表:方法输入

recevier type: 表示这个方法和 yupe 这个类型绑定,或者说该方法作用于 type 类型,recevier type 可以是结构体,也可以使其他自定义类型

recevier: 就是 type 类型的一个实例变量

返回值列表: 表示返回的值,可以多个

方法主体: 表示为了实现某一功能代码块

return: return 语句不是必须的
====

[NOTE]
====
接受者类型必须是 `T` 或者 `*T` ,这里的 `T` 是类型名,T叫做接受者基础类型或者简称基础类型,基础类型一定不能是指针或接口类型,这样会引起 `invalid receiver type ...` 的编译错误.并且定义在与方法相同的包中
====

我们以上面的例子 Person 结构体为例,为 Person 定义如下方法

[source,go]
----
package main

import (
	"fmt"
)

type Person struct {
	Name string
	Age int
	Scpres [5]float64
	ptr *int
	slice []int
	map1 map[string]string
}

// 定义一个方法,打印 我是一个好人
func (p Person) speak(){
	fmt.Println(p.Name,"我是一个好人")
}

// 计算 1+2+...+1000
func (p Person) cale(){
	res := 0
	for i :=0 ;i<1000; i++{
		res += i
	}
	fmt.Println(p.Name,"计算结果是:",res)
}

// 计算 1+2+...+n
func (p Person) cale2(n int){
	res := 0
	for i :=0 ;i < n; i++{
		res += i
	}
	fmt.Println(p.Name,"计算结果是:",res)
}

// 计算 n1+n2
func (p Person) getSum(n1 int,n2 int) (res int){
	res = n1 + n2
	return
}
type Monster struct {
	Name string `json:"name"`
	Age int `json:"age"`
	Skill string `json:"skill"`
}

func main(){
	person := Person{}
	person.Name = "Jcohy"
	person.speak() // Jcohy 我是一个好人
	person.cale() // Jcohy 计算结果是: 499500
	person.cale2(10) // Jcohy 计算结果是: 45
	res := person.getSum(25,25)
	fmt.Println("getSum=",res) // getSum= 50
}
----

==== 方法的调用和传参机制

方法的调用和传参机制和函数基本一样,不一样的地方式方法调用时,会将调用方法的变量,当作实参也传递给方法

image::{base-images}/go4.png[]

变量调用方法时,该变量本身也会作为一个参数传递到方法(如果变量时值类型,则进行值拷贝,如果变量时引用类型,则进行地址拷贝)

==== 注意事项

. 结构体类型是值类型,在方法调用中,遵守值类型的传递机制,是值拷贝传递方式
. 如果希望在方法中,修改结构体变量的值,可以通过结构体指针的方式来处理
. Golang 中的方法作用在指定的数据类型上的,因此自定义类型都可以有方法,而不仅仅是 `struct`,比如 `int`,`float32` 都可以有方法
. 方法的访问范围控制的规则,和函数一样.方法名首字母小写,只能在本包访问,方法首字母大写,可以在本包和其他包访问
. 如果一个类型实现了 `String()` 这个方法,那么 `fmt.println` 默认调用这个变量的 `String()` 方法进行输出

[[go-oop-struct-sample]]
=== 应用实例

[[go-oop-struct-sample-factory]]
==== 工厂模式的函数

[[go-oop-interface]]
== 接口(interface)

interface 类型可以定义一组方法,但是这些不需要实现,并且 interface 不能包含任何变量.到某个自定义类型要使用的时候,再根据具体情况把这些方法实现写出来

接口的基本语法

[source,go]
----
type 接口名 interface{
	method1(参数列表) 返回值列表
	method2(参数列表) 返回值列表
	...
}
----

接口的实现

[source,go]
----
func (t 自定义类型) method1(参数列表) 返回值列表{
	// 方法实现
}
func (t 自定义类型) method2(参数列表) 返回值列表{
	// 方法实现
}
...
----

Golang 中的接口,不需要显式的实现,只要一个变量,含有接口类型中的所有方法,那么这个变量就实现这个接口.因此,Golang 中没有 `implement` 这样的关键字

[[go-oop-interface-sample]]
=== 示例

====
[source,go]
----
package main

import "fmt"


type Usb interface { //<1>
	Start() //<2>
	Stop()
}

type Phone struct {

}


func (p Phone) Start(){ //<3>
	fmt.Println("手机开始工作")
}

func (p Phone) Stop(){
	fmt.Println("手机停止工作")
}

type Camera struct {

}

func (c Camera) Start(){ // <4>
	fmt.Println("相机开始工作")
}

func (c Camera) Stop(){
	fmt.Println("相机停止工作")
}

type Computer struct {

}

func (c Computer) Working(usb Usb){ // <5>
	usb.Start()
	usb.Stop()
}

func main(){
	computer := Computer{}
	phone := Phone{}
	camera := Camera{}

	computer.Working(phone)// 手机开始工作 手机停止工作
	computer.Working(camera)// 相机开始工作 相机停止工作
}
----
<1> 定义一个接口
<2> 声明两个没有实现的方法
<3> 让 Phone 实现 Usb 的方法
<4> 让 Camera 实现 Usb 的方法
<5> 编写一个 Working 方法,接收一个 Usb 接口类型的变量,是要实现了 Usb 接口,usb 变量会根据传入的实参,来判断到底是 phone 还是 camera
====

接口注意事项

. 接口本省不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量
. 接口里的所有方法都没有方法体,即接口的方法都是没有实现的方法,接口体现了程序设计的多态和高内聚低耦合的思想
. 在 Golang 中,一个自定义类型需要将某个接口的所有方法都实现,我们说这个自定义类型实现了该接口
. 一个自定义类型只有实现了某个接口,才能将该自定义类型的实例(变量)赋给接口类型
. 只要自定义数据类型,就可以实现接口,不仅仅是结构体类型
. 一个自定义类型可以实现多个接口
. Golang 接口中不能有任何变量
. 一个接口(比如 A 接口)可以继承多个别的接口(B,C 接口),这是如果要实现 A 接口,也必须将 B,C 接口的方法也全部实现
. `interface` 类型默认是一个指针(引用类型),如果没有对 `interface` 初始化就使用,那么会输出 nil
. 空接口 `interface{}` 没有任何方法,所以所有类型都实现了空接口,即我们可以把任何一个变量赋给空接口

[[go-oop-abstract]]
== 抽象

我们在前面定义一个结构体的时候,实际上就是把一类事物的共有属性(字段)和行为(方法) 提取出来,形成了一个 物理模型(结构体),这种 **研究问题的方法** 称为抽象

[[go-oop-encapsulation]]
== 封装

封装(encapsulation)就是把抽象出来的字段和对字段的操作封装在一起,数据被保护在内部,程序的其他包只有通过被授权的操作(方法),才能对字段进行操作

封装的实现步骤

. 将结构体,字段(属性)的首字母小写(不能导出了,其他包也不能使用,类似 private)
. 给结构体所在的包提供一个 <<go-oop-struct-sample>>,首字母大写,类似一个构造函数
. 提供一个首字母大写的 Set 方法(类似其他语言的 public),用于对属性判断并赋值
+
[source,go]
----
func (var 结构体类型名) SetXxx(参数列表) (返回值列表){
	var.字段 = 参数
}
----
. 提供一个首字母大写的 Get 方法(类似其他语言的 public),用于获取属性的值
+
[source,go]
----
func (var 结构体类型名) GetXxx() (返回值列表){
	return var.字段
}
----

[NOTE]
====
在 Golang 开发中并没有特别强调封装,这点并不像 Java,所以提醒学过 Java 的朋友,不用总是用 Java 的语言特性来看待 Golang,Golang 本身对面向对象的特性做了简化的
====

我们来看一个案例:设计一个程序,不能随便查看人的年龄,工资等隐私,并对输入的年龄进行合理的验证.

设计: `model` 包(`person.go`) `main` 包(`main.go`,调用 `Person` 结构体)

[source,go,indent=0,subs="verbatim,quotes",role="primary"]
.person.go
----
package model

import "fmt"

type person struct {
	Name string
	age int
	sal float64
}

// 写一个工厂模式额函数,相当于构造函数
func NewPerson(name string) *person{
	return &person{
		Name:name,
	}
}

func (p *person) SetAge(age int){
	if age > 0 && age < 150 {
		p.age = age
	}else{
		fmt.Println("年龄范围不正确")
	}
}

func (p *person) GetAge() int {
	return p.age
}

func (p *person) SetSal(sal float64){
	if sal >= 3000 && sal <= 30000{
		p.sal = sal
	} else {
		fmt.Println("薪水范围不正确")
	}
}

func (p *person) GetSal() float64 {
	return p.sal
}
----
.main.go
[source,go,indent=0,subs="verbatim,quotes",role="secondary"]
----
package main

import (
	"fmt"
	"model"
)

func main(){
	p := model.NewPerson("jcohy")
	p.SetAge(12)
	p.SetSal(6666)
	fmt.Println(p) // &{jcohy 12 6666}

	fmt.Println(p.Name,"age=",p.GetAge(),"sal=",p.GetSal()) // jcohy age= 12 sal= 6666
}
----

[[go-oop-extends]]
== 继承

继承可以解决代码复用的问题,当多个结构体存在相同的属性(字段)和方法时,可以从这些结构体中抽象出结构体,在该结构体中定义这些相同的属性和方法.也就是说,在 Golang 中,如果一个 struct 嵌套了另一个匿名的结构体,
那么这个结构体可以直接访问匿名结构体的字段呵呵方法,从而实现了继承的特性

嵌套匿名结构体的语法

[source,go]
----
package main

import "fmt"

type Goods struct{
	Name string
	Price int
}
type Book struct{
	Goods // 这里就是嵌套匿名结构体 Goods
	Writer string
}
----

我们来看一个案例:编写一个学生考试系统

====
[source,go]
----
package main

import "fmt"

type Student struct {
	Name string
	age int
	Score int
}

// 将 Pupil 和 Graduate 共有的方法绑定到 *Student
func (stu *Student) ShowInfo(){
	fmt.Printf("学生名=%v 年龄=%v 成绩=%v\n",stu.Name,stu.age,stu.Score)
}

func (stu *Student) SetScore(score int){
	//业务判断
	stu.Score = score
}

// 小学生
type Pupil struct {
	Student // 嵌入了 Student 匿名结构体
}

func (p *Pupil) testing(){
	fmt.Println("小学生正在考试......")
}

// 大学生
type Graduate struct {
	Student // 嵌入了 Student 匿名结构体
}

func (p *Graduate) testing(){
	fmt.Println("大学生正在考试......")
}

func main(){
	pupil := &Pupil{}
	pupil.Student.Name = "tom"
	pupil.Student.age = 8 // <1>
	pupil.testing() // 小学生正在考试......
	pupil.SetScore(56)
	pupil.ShowInfo() // 学生名=tom 年龄=8 成绩=56

	graduate := &Graduate{}
	graduate.Name = "mary"
	graduate.age = 28 // <2>
	graduate.testing() // 大学生正在考试......
	graduate.SetScore(90)
	graduate.ShowInfo() // 学生名=mary 年龄=28 成绩=90
}
----
<1> 结构体可以使用嵌套匿名结构体的所有字段和方法,即首字母大写或小写的字段方法都可以访问
<2> 匿名结构体字段访问可以简化
====

. 当结构体和匿名结构体有相同的字段或者访问方法时,编译器采用就近访问原则,如果希望访问匿名结构体的字段和方法,可以通过匿名结构体名来区分
. 结构体嵌入两个(或多个)匿名结构体,如果两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法),在访问时,就必须明确指定匿名结构体名字,否则编译报错
. 如果一个 struct 嵌套了一个有名的结构体,这种模式就是组合,如果是组合关系,那么在访问组合的结构体的字段或方法时,必须带上结构体的名字
+
[source,go]
----
package main

import (
	"fmt"
)

type A struct {
	Name string
}

type B struct {
	a A
}
func main() {
	var b B
	b.a.Name = "jack"
	fmt.Println(b.a.Name)
}
----
. 嵌套匿名结构体后,也可以在创建结构体变量(实例)时,直接指定各个匿名结构体字段的值
+
[source,go]
----
package main

import (
	"fmt"
)

type Goods struct {
	Name string
	Price float64
}

type Brand struct {
	Name string
	Address string
}

type TV struct {
	Goods
	Brand
}

type TV2 struct {
	*Goods
	*Brand
}

func main(){
	tv := TV{Goods{"电视机01",19999.9},Brand{"海尔","山东"}}

	tv2 := TV{Goods{"电视机02",29999.9},Brand{"夏普","北京"}}

	fmt.Println("tv",tv)
	fmt.Println("tv2",tv2)

	tv3 := TV2{&Goods{"电视机03",39999.9},&Brand{"创维","河南"}}

	tv4 := TV2{&Goods{"电视机04",49999.9},&Brand{"长虹","四川"}}

	fmt.Println("tv3",*tv3.Goods,*tv3.Brand)
	fmt.Println("tv4",*tv4.Goods,*tv4.Brand)
}
----
. 结构体的匿名字段是基本数据类型,就不能有第二个,如果需要多个基本类型的字段,则必须给字段指定名字
+
[source,go]
----
type E struct {
	int
	n int
}
func main() {
	var e E
	e.n = 20
	e.int = 30
	fmt.Println("e=",e)
}
----

[[go-oop-polymorphism]]
== 多态

在 Go 语言,多态的特性是通过 <<go-oop-interface>> 实现的.可以按照统一的接口来调用不同的实现.

接口体现多态的两种形式,第一种就如 <<go-oop-interface-sample>> 所示,通过参数实现多态.第二种是通过多态数组,我们将此例进行修改,来使用多态数组来实现多态

[source,go]
----
package main

import "fmt"


type Usb interface {
	Start()
	Stop()
}

type Phone struct {
	name string
}

func (p Phone) Start(){
	fmt.Println("手机开始工作")
}

func (p Phone) Stop(){
	fmt.Println("手机停止工作")
}

type Camera struct {
	name string
}

func (c Camera) Start(){
	fmt.Println("相机开始工作")
}

func (c Camera) Stop(){
	fmt.Println("相机停止工作")
}

type Computer struct {

}

func (c Computer) Working(usb Usb){
	usb.Start()
	usb.Stop()
}

func main(){
	computer := Computer{}
	phone := Phone{}
	camera := Camera{}

	computer.Working(phone)// 手机开始工作 手机停止工作
	computer.Working(camera)// 相机开始工作 相机停止工作

	var usbArr [3]Usb
	usbArr[0] = Phone{"苹果"}
	usbArr[1] = Phone{"华为"}
	usbArr[2] = Camera{"索尼"}

	fmt.Println(usbArr) // [{苹果} {华为} {索尼}]
}
----

=== 类型断言

由于接口是一般类型,不知道具体类型,如果要转成具体类型,就需要使用类型断言,看下面的例子

====
[source,go]
----
package main

import "fmt"

func main()  {
 var x interface{}
 var b2 float32 = 1.1
 x = b2 // <1>
 y := x.(float32) // <2>

 fmt.Printf("y 的类型是 %T,值是 %v",y,y) // y 的类型是 float32,值是 1.1
}
----
<1> 空接口,可以接收任何类型
<2> 使用类型断言,如果类型不匹配,就会报 panic ,因此进行类型断言时,要确保原来的空接口指向的就是断言的类型
====

如何在进行断言的时候,带上检测机制,如果成功就 ok,否则也不要报 panic

[source,go]
----
package main

import "fmt"

func main() {
	var x interface{}
	var b2 float32 = 2.1
	x = b2 // 空接口,可以接收任何类型
	// x => float32 [使用类型断言]
	// y := x.(float32)
	// fmt.Printf("y 的类型是 %T,值是 %v", y, y) // y 的类型是 float32,值是 1.1

	if y, ok := x.(float32); ok {
		fmt.Println("SUCCESS")                 // y 的类型是 float32,值是 1.1
		fmt.Printf("y 的类型是 %T,值是 %v \n", y, y) // y 的类型是 float32,值是 1.1
	} else {
		fmt.Println("FAIL") //
	}
	fmt.Println("继续执行") //
}
----