[[go-reflect]]
= 反射

[[go-reflect-overview]]
== 概述

反射可以在运行时动态获取变量的各种信息, 比如变量的类型(Type), 类别(Kind). 如果是结构体变量, 还可以获取到结构体本身的信息(包括结构体的字段, 方法). 通过反射, 可以修改变量的值, 调用关联的方法. 使用反射, 需要 `import "reflect"`

`reflect.TypeOf(变量名)`, 获取变量的类型, 返回 `reflect.Type` 类型

`reflect.ValueOf(变量名)`, 获取变量的值, 返回 `reflect.Value` 类型.  `reflect.Value` 是一个结构体类型, 通过 `reflect.Value` 可以获取到关于该变量的很多信息

变量, `interface{}` 和 `reflect.Value` 是可以相互转换的, 这点在实际开发中会经常用到

====
[source,go]
----
package main

import (
	"fmt"
	"reflect"
)

func main(){
	var num int

	test(num)
}

func test(b interface{}){

	rVal := reflect.ValueOf(b) // <1>

	iVal := rVal.Interface() // <2>

	v := iVal.(int) // <3>

	fmt.Printf("v 的类型为 %T ,v 的值为 %v\n",v,v) // v 的类型为 int ,v 的值为 0
}
----
<1> 将 `interface{}` 转为 `reflect.Value`
<2> 将 `reflect.Value` 转为 `interface{}`
<3> 将 `interface{}` 转成原来的变量类型, 使用 <<go-oop-polymorphism-predicate>>
====

image::{oss-images}/go8.png[]

反射常使用的场景有以下两种

. 不知道接口调用那个函数, 根据传入参数在运行时确定调用的具体接口, 这种需要对函数或方法反射.
. 对于结构体序列化时, 如果结构体有指定 Tag, 也会使用到反射生成对应的字符串

[[go-reflect-use]]
== 操作

通过下面这个案例来演示反射的基本操作

[source,go]
----
package main
import (
	"reflect"
	"fmt"
)

//专门演示反射
func reflectTest01(b interface{}) {

	//通过反射获取的传入的变量的 type , kind, 值
	//1. 先获取到 reflect.Type
	rTyp := reflect.TypeOf(b)
	fmt.Println("rType=", rTyp)

	//2. 获取到 reflect.Value
	rVal := reflect.ValueOf(b)

	n2 := 2 + rVal.Int()
	//n3 := rVal.Float()
	fmt.Println("n2=", n2)
	//fmt.Println("n3=", n3)

	fmt.Printf("rVal=%v rVal type=%T\n", rVal, rVal)

	//下面我们将 rVal 转成 interface{}
	iV := rVal.Interface()
	//将 interface{} 通过断言转成需要的类型
	num2 := iV.(int)
	fmt.Println("num2=", num2)


}

//专门演示反射[对结构体的反射]
func reflectTest02(b interface{}) {

	//通过反射获取的传入的变量的 type , kind, 值
	//1. 先获取到 reflect.Type
	rTyp := reflect.TypeOf(b)
	fmt.Println("rType=", rTyp)

	//2. 获取到 reflect.Value
	rVal := reflect.ValueOf(b)

	//3. 获取 变量对应的Kind
	//(1) rVal.Kind() ==>
	kind1 := rVal.Kind()
	//(2) rTyp.Kind() ==>
	kind2 := rTyp.Kind()
	fmt.Printf("kind =%v kind=%v\n", kind1, kind2)

	//下面我们将 rVal 转成 interface{}
	iV := rVal.Interface()
	fmt.Printf("iv=%v iv type=%T \n", iV, iV)
	//将 interface{} 通过断言转成需要的类型
	//这里, 我们就简单使用了一带检测的类型断言.
	//同学们可以使用 swtich 的断言形式来做的更加的灵活
	stu, ok := iV.(Student)
	if ok {
		fmt.Printf("stu.Name=%v\n", stu.Name)
	}

}

type Student struct {
	Name string
	Age int
}

type Monster struct {
	Name string
	Age int
}

func main() {

	//请编写一个案例,
	//演示对(基本数据类型、interface{}、reflect.Value)进行反射的基本操作

	//1. 先定义一个int
	var num int = 100
	reflectTest01(num)

	//2. 定义一个Student的实例
	stu := Student{
		Name : "tom",
		Age : 20,
	}
	reflectTest02(stu)
}
----

[[go-reflect-notice]]
== 注意事项

. reflect.Value.Kind 获取变量的类别, 返回的是一个常量
. Type 和 Kind 的区别
+
Type 是类型, Kind是类别, Type 和 Kind 可能是相同的, 也可能是不同的
. 通过反射可以让变量在 `interface{}` 和 `reflect.Value` 之间相互转换
. 使用反射的方式来获取变量的值, 并返回对应的类型, 要求数据类型匹配, 比如 `x` 是 `int` ,那么就应该使用 `reflect.Value(x).Int()`,而不能使用其他的, 否则报 `panic`
. 通过反射来修改变量, 注意当使用 SetXxx 方法来设置需要通过对应的指针类型来完成, 这样才能改变传入的变量的值, 同事也需要使用到 `reflect.Value.Elem()` 方法
+
[source,go]
----
package main
import (
	"fmt"
	"reflect"
)
func main() {
	var str string = "tom"   //ok
	fs := reflect.ValueOf(&str) //ok fs -> string
	fs.Elem().SetString("jack") //ok
	fmt.Printf("%v\n", str) // jack
}
----

[[go-reflect-sample]]
== 案例

示例一: 使用反射来遍历结构体字段, 调用结构体方法, 并获取结构体标签的值

[source,go]
----
package main
import (
	"fmt"
	"reflect"
)
//定义了一个Monster结构体
type Monster struct {
	Name  string `json:"name"`
	Age   int `json:"monster_age"`
	Score float32 `json:"成绩"`
	Sex   string

}

//方法, 返回两个数的和
func (s Monster) GetSum(n1, n2 int) int {
	return n1 + n2
}
//方法,  接收四个值, 给s赋值
func (s Monster) Set(name string, age int, score float32, sex string) {
	s.Name = name
	s.Age = age
	s.Score = score
	s.Sex = sex
}

//方法, 显示s的值
func (s Monster) Print() {
	fmt.Println("---start~----")
	fmt.Println(s)
	fmt.Println("---end~----")
}
func TestStruct(a interface{}) {
	//获取reflect.Type 类型
	typ := reflect.TypeOf(a)
	//获取reflect.Value 类型
	val := reflect.ValueOf(a)
	//获取到a对应的类别
	kd := val.Kind()
	//如果传入的不是struct, 就退出
	if kd !=  reflect.Struct {
		fmt.Println("expect struct")
		return
	}

	//获取到该结构体有几个字段
	num := val.NumField()

	fmt.Printf("struct has %d fields\n", num) //4
	//变量结构体的所有字段
	for i := 0; i < num; i++ {
		fmt.Printf("Field %d: 值为=%v\n", i, val.Field(i))
		//获取到struct标签, 注意需要通过reflect.Type来获取tag标签的值
		tagVal := typ.Field(i).Tag.Get("json")
		//如果该字段于tag标签就显示, 否则就不显示
		if tagVal != "" {
			fmt.Printf("Field %d: tag为=%v\n", i, tagVal)
		}
	}

	//获取到该结构体有多少个方法
	numOfMethod := val.NumMethod()
	fmt.Printf("struct has %d methods\n", numOfMethod)

	//var params []reflect.Value
	//方法的排序默认是按照 函数名的排序(ASCII码)
	val.Method(1).Call(nil) //获取到第二个方法. 调用它


	//调用结构体的第1个方法Method(0)
	var params []reflect.Value  //声明了 []reflect.Value
	params = append(params, reflect.ValueOf(10))
	params = append(params, reflect.ValueOf(40))
	res := val.Method(0).Call(params) //传入的参数是 []reflect.Value, 返回[]reflect.Value
	fmt.Println("res=", res[0].Int()) //返回结果, 返回的结果是 []reflect.Value*/

}
func main() {
	//创建了一个Monster实例
	var a Monster = Monster{
		Name:  "黄鼠狼精",
		Age:   400,
		Score: 30.8,
	}
	//将Monster实例传递给TestStruct函数
	TestStruct(a)
}
----