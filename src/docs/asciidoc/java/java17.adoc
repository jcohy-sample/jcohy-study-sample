[[java-17-feature]]
= Java 17 新特性

[[java-17-feature-overview]]
== Java 17 新特性一览

2021 年 9 月 14 日,JDK/Java 17 正式 GA(General Available) 正式发布.

根据发布的规划，这次发布的 JDK 17 将是一个长期支持版（LTS 版）。LTS 版每 3 年发布一个，上一次长期支持版是 18 年 9 月发布的 JDK 11。

Java 17 为用户提供了 14 项主要的 JEP (Java/JDK Enhancement Proposals,JDK 增强提案)，包括两个孵化器模块，一个预览功能

资料来源:  http://openjdk.java.net/projects/jdk/17/

[[java-17-feature-overview-tbl]]
.Java 17 新特性一览
|===
| 新特性 | 翻译

| 306: https://openjdk.java.net/jeps/306[Restore Always-Strict Floating-Point Semantics] | 恢复始终严格的浮点语义

| 356: https://openjdk.java.net/jeps/356[Enhanced Pseudo-Random Number Generators] | 增强型伪随机数发生器

| 382: https://openjdk.java.net/jeps/382[New macOS Rendering Pipeline] | 新的 macOS 渲染管道

| 391 https://openjdk.java.net/jeps/391[macOS/AArch64 Port] | macOS/AArch64 平台支持

| 398: https://openjdk.java.net/jeps/398[Deprecate the Applet API for Removal] | 标记删除的 Applet API

| 403: http://openjdk.java.net/jeps/403[Strongly Encapsulate JDK Internals] | 强封装 JDK 的内部 API

| 406: http://openjdk.java.net/jeps/406[Pattern Matching for switch (Preview)] | Switch 模式匹配（预览）

| 407: http://openjdk.java.net/jeps/407[Remove RMI Activation] | 删除 RMI Activation

| 409: http://openjdk.java.net/jeps/409[Sealed Classes] | 密封类

| 410: http://openjdk.java.net/jeps/410[Remove the Experimental AOT and JIT Compiler] | 删除实验性 AOT 和 JIT 编译器

| 411: http://openjdk.java.net/jeps/411[Deprecate the Security Manager for Removal] | 弃用即将删除安全管理器

| 412: http://openjdk.java.net/jeps/412[Foreign Function & Memory API (Incubator)] | 外部函数和内存 API（孵化器）

| 414: http://openjdk.java.net/jeps/414[Vector API (Second Incubator)] | Vector API（第二次进行特性孵化）

| 415: http://openjdk.java.net/jeps/415[Context-Specific Deserialization Filters] | 特定于上下文的反序列化过滤器
|===

[[java-17-feature-environment]]
== 环境安装

* JDK 下载地址:
+
OpenJDK版本: https://jdk.java.net/17/
+
Oracle版本: https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html

* 修改环境变量.

[[java-17-feature-floating]]
== 恢复始终严格的浮点语义

与其同时拥有严格的浮点语义 (strictfp) 和显着不同的默认浮点语义，不如让浮点运算统一严格。这将使语言和虚拟机恢复到它们原来的浮点语义，就像在 Java SE 1.2 中引入严格和默认浮点模式之前一样。

[[java-17-feature-floating-goals]]
=== 目标

* 简化数字敏感的库的开发，包括 `java.lang.Math` 和 `java.lang.StrictMath`。
* 在一些棘手的平台上提供更多的规律性。

[[java-17-feature-floating-non-goals]]
=== 非目标

* 不是定义 "fast-fp" 或 "loose-fp"  (c.f. https://jcp.org/en/jsr/detail?id=84[JSR 84]: Floating Point Extensions).

[[java-17-feature-random]]
== 增强型伪随机数发生器

引入了伪随机数生成器 (PRNG) 的新接口和实现，其中包括可跳转 PRNG 和一类新的可拆分 PRNG 算法 (LXM)。

[[java-17-feature-random-goals]]
=== 目标

* 使在不同的应用程序中使用不同的 PRNG 算法变得更简单。
* 通过提供 PRNG 对象的流，您可以更好地支持基于流的编程。
* 从当前 PRNG 组中删除冗余代码。
* 尽可能维护 java.util.Random 类的动作。

[[java-17-feature-random-non-goals]]
=== 非目标

* 他的目标不是提供其他 PRNG 算法的实现，而是提供一个能够包含其他 PRNG 算法的框架。但是，我们已经添加了三种常见算法，这些算法已经被广泛的应用于其他编程语言环境中。

[[java-17-feature-random-non-description]]
=== 描述

我们提供了一个新的接口 `RandomGenerator`，它为所有现有的和新的 PRNGs 提供了统一的 API。`RandomGenerators` 提供了名为 ints、longs、doubles、nextBoolean、nextInt、nextLong、nextDouble 和 nextFloat 的方法，以及它们当前的所有参数变化。

我们提供了四个新的特定 RandomGenerator  接口:

* `SplittableRandomGenerator` 继承 `RandomGenerator` 接口，并提供了 `split` 和 `splits` 方法. Splittability 允许用户从现有的 `RandomGenerator` 生成一个新的 `RandomGenerator`，后者通常会产生统计上独立的结果。
* `JumpableRandomGenerator`  继承 `RandomGenerator`，并且提供了 `jump` 和 `jumps` 方法. Jumpability 允许用户指定合适跳跃的步长。
* `LeapableRandomGenerator` 继承 RandomGenerator，并且提供了 `leap` 和 `leaps`. Leapability 允许用户跳跃的步长更大一些.
* `ArbitrarilyJumpableRandomGenerator`  继承 `LeapableRandomGenerator` 还提供了跳跃和跳跃的额外变化，允许指定任意跳跃距离。

提供了一个新的类 `RandomGeneratorFactory`，用于构造 `RandomGenerator` 实现的实例。`RandomGeneratorFactory` 使用 `ServiceLoader`.Provider API 注册 RandomGenerator 实现。

我们已经重构了 `Random`、`ThreadLocalRandom` 和 `SplittableRandom`，以便它们共享大部分实现的代码，而且，这些代码也可以被其他算法重用。这个重构创建了 non-public 抽象类 `AbstractRandomGenerator`, `AbstractSplittableRandomGenerator`, `AbstractJumpableRandomGenerator`, `AbstractLeapableRandomGenerator`，`AbstractArbitrarilyJumpableRandomGenerator`，每个只提供方法 `nextInt()`, `nextLong()` 的实现，和(如果相关) `split()`, 或 `jump()`, 或 `jump()` 和 `leap()`, 或 `jump(distance)`。在这个重构之后，`Random`、`ThreadLocalRandom` 和 `SplittableRandom`  继承了 `RandomGenerator` 接口。请注意，因为 `SecureRandom`  是 `Random` 的子类，所有的 `SecureRandom`  实例也自动支持 `RandomGenerator` 接口，而不需要重新编码 `SecureRandom`  类或任何相关的实现引擎。

我们还添加了底层的 non-public 类，扩展了 `AbstractSplittableRandomGenerator` (因此实现了 `SplittableRandomGenerator` 和 `RandomGenerator`)，以支持 LXM 家族 PRNG 算法的 6 个特定成员:

* L32X64MixRandom
* L32X64StarStarRandom
* L64X128MixRandom
* L64X128StarStarRandom
* L64X256MixRandom
* L64X1024MixRandom
* L128X128MixRandom
* L128X256MixRandom
* L128X1024MixRandom

LXM 算法的核心 `nextLong` (或 `nextInt` )方法的结构遵循了 Sebastiano Vigna 在 2017 年 12 月提出的建议，即使用一个 LCG 子生成器和一个基于 xor 的子生成器(而不是两个 LCG 子生成器)将提供更长的周期、优越的均匀分布、可伸缩性和更好的质量。这里的每一个具体实现都结合了当前最著名的基于 xor 的生成器之一（xoroshiro 或 xoshiro，由 Blackman 和 Vigna 在 ACM Trans 的 "Scrambled Linear Pseudorandom Number Generators" ACM Trans. Math. Softw., 2021）。使用目前最著名的乘数之一(2019 年由 Steele 和 Vigna 在搜索更好的乘数时发现)的 LCG，然后应用 Doug Lea 识别的混合函数。测试已经证实，LXM 算法在质量上远远优于 `SplittableRandom` 使用的 SplitMix 算法(2014)。

我们还提供了这些广泛使用的PRNG算法的实现:

* Xoshiro256PlusPlus
* Xoroshiro128PlusPlus

上面提到的 non-public  抽象实现将来可能作为随机数实现者 SPI 的一部分提供。

这套算法为 Java 程序员提供了在空间、时间、质量以及与其他语言的兼容性之间的合理权衡范围。

[[java-17-feature-random-non-alternatives]]
=== 备选方案

我们考虑简单地引入新的接口，同时留下随机，ThreadLocalrandom和Splittablerandom的实现。这将有助于使PRNG对象更容易可互换，但不会使其更容易实现它们。

我们考虑重构随机，ThreadLocalrandom和SplittableAndom，而不改变其功能或添加任何新接口。我们相信这将减少其整体内存足迹，但无需更轻松地实现未来的PRNG算法即可更轻松地实现或使用。

我们考虑简单地引入新的接口，同时保持 `Random`、`ThreadLocalRandom` 和 `SplittableRandom`  的实现不变。这将有助于使 PRNG 对象更容易互换，但不会使其更容易实现它们。

我们考虑在不改变它们的功能或添加任何新接口的情况下重构 `Random`、`ThreadLocalRandom` 和 `SplittableRandom`。我们相信这将减少它们的总体内存占用，但不会使未来的 PRNG 算法更容易实现或使用。

[[java-17-feature-macos]]
== 新的 macOS 渲染管道

需要使用新的 Apple Metal 框架为 macOS 提供新的 Java 2D 渲染管道。与今天一样，Java 2D 完全依赖于 OpenGL。虽然 Apple 在 macOS 10.14 中弃用了 OpenGL 渲染库，但 Metal 框架取代了 OpenGL 渲染库。

[[java-17-feature-macos-goals]]
=== 目标

* 为基于 macOS Metal 框架的 Java 2D API 提供功能齐全的渲染管道。
* 做好准备，以防苹果从未来版本的 macOS 中移除已弃用的 OpenGL API。
* 确保新的管道到 Java 应用程序是透明的。
* 确保实现的功能与现有的 OpenGL 管道相同。
* 在选择的实际应用程序和基准测试中，提供与 OpenGL 管道相当或更好的性能。
* 创建一个适合现有 Java 2D 管道模型的干净的体系结构。
* 与 OpenGL 管线共存，直至停产。

[[java-17-feature-macos-non-goals]]
=== 非目标

* 移除或禁用现有的 OpenGL 管道并不是目标。
* 我们的目标不是添加任何新的 Java 或 JDK api。这都是内部实现。

[[java-17-feature-platform]]
== macOS/AArch64 平台支持

将 JDK 移植到新架构 macOS/AArch64 期待未来需求

Apple 决定在其 Macintosh 计算机上从 x64 迁移到 AArch64。对于 Linux，AArch64 版本的 Java 已经可用，Windows 端口上的开发目前正在进行中。

由于程序二进制接口和保留处理器寄存器的集合等低级约定的差异，Java 开发人员计划通过使用条件编译来重用来自这些端口的现有 AArch64 代码，这是 JDK 端口中的标准。

MacOS/AArch64 的更改有可能拆分当前的 Linux/AArch64、Windows/AArch64 和 MacOS/x64 端口，尽管可以通过预集成测试来减轻这种可能性。

[[java-17-feature-applet]]
== 标记删除的 Applet API

Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。虽然 Applet API 在 Java 9 中的 https://openjdk.java.net/jeps/289[JEP 289] 已被弃用，但之前并未将其删除。

[[java-17-feature-description]]
=== 描述

移除标准 Java API 的这些类和接口:

* java.applet.Applet
* java.applet.AppletStub
* java.applet.AppletContext
* java.applet.AudioClip
* javax.swing.JApplet
* java.beans.AppletInitializer

弃用并删除任何引用上述类和接口的API元素，包括方法和字段:

* java.beans.Beans
* javax.swing.RepaintManager
* javax.naming.Context

[[java-17-feature-jdk]]
== 强封装 JDK 的内部 API

强烈封装了 JDK 的所有内部元素，除了关键的内部 API，如 `sun.misc.Unsafe`。不再可能像从 JDK 9 到 JDK 16 那样，使用单个命令行选项来放松对内部部件的严格封装。

[[java-17-feature-jdk-goals]]
=== 目标

* 继续提高 JDK 的安全性和可维护性，这是 Project Jigsaw 的主要目标之一。
* 鼓励开发人员从内部部件转向标准 API，以便他们和他们的用户可以轻松升级到未来的 Java 版本。

[[java-17-feature-switch]]
== Switch 模式匹配（预览）

通过对 Switch 表达式和语句的模式匹配以及对模式语言的扩展来增强 Java 编程语言。允许针对各种模式验证 switch 表达式和语句，每个模式都有不同的操作。这使得以简单和安全的方式表达复杂的面向数据的查询成为可能。

[[java-17-feature-switch-goals]]
=== 目标

* 允许模式出现在 case 语句中，扩展 switch 表达式和语句的表达性和适用性。
* 如果需要，让历史转折点的零敌意放松。
* 将引入两种新模式：:保护模式，使用任意布尔表达式来优化模式匹配逻辑，以及带括号的模式：清除解析歧义。
* 确保所有现有的 switch 表达式和语句都使用相同的语义进行编译，并在不做任何修改的情况下执行它们。
* 不要引入与传统 switch 结构分离的模式匹配语义的新的类似于 switch 的表达式或语句。
* 当 case 标签是模式时，不要使 switch 表达式或语句的行为与 case 标签是传统常量时不同。

[[java-17-feature-switch-motivation]]
=== 动机

在 Java 16 中，https://openjdk.java.net/jeps/394[JEP 394] 扩展了 instanceof 操作符，以接受类型模式并执行模式匹配。这个扩展可以简化熟悉的实例和转换习惯用法:

[source,java]
----
// Old code
if (o instanceof String) {
    String s = (String)o;
    ... use s ...
}

// New code
if (o instanceof String s) {
    ... use s ...
}
----

我们经常希望可以将一个变量(如 o )与多个选项进行比较。Java 支持使用 switch 语句进行多路比较，并且从 Java 14 开始，支持 switch 表达式(https://openjdk.java.net/jeps/361[JEP 361])，但不幸的是 switch 非常有限。您只能对 numeric 类型、enum 类型和 String 类型进行比较，并且只能测试常量的相等性。我们可能希望使用模式来针对多个可能性测试相同的变量，对每个可能性采取特定的操作，但由于现有的 switch 不支持这种操作，我们最终会得到一个 if...else 链，如:

[source,java]
----
static String formatter(Object o) {
    String formatted = "unknown";
    if (o instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (o instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (o instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (o instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}
----

这段代码受益于使用 instanceof 表达式，但它并不完美。首先，这种方法可能隐藏了错误的编码，因为我们使用了这种控制结构。目的是在  if...else 的每个分支中为 formatted 赋值。但是没有任何东西使编译器能够识别和验证不变性。如果某些分支 - 也许很少执行的分支 - 没有分配给 formatted，那么就会出现错误。(将 formatted 声明为空的局部变量至少会在此工作中获得编译器的确定赋值分析，但这样的声明并不总是可以编写的。)此外，上面的代码是不可优化的，它的时间复杂度将为O(n)，尽管潜在的问题通常是O(1)。

但是 switch 是一个完美的用来进行匹配的模式匹配!如果我们将 switch 语句和表达式扩展到任何类型，并且允许 case 标签使用模式而不仅仅是常量，那么我们就可以更清晰、更可靠地重写上面的代码:

[source,java]
----
static String formatterPatternSwitch(Object o) {
    return switch (o) {
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        default        -> o.toString();
    };
}
----

这个 switch 的语义很清楚:带有模式的 case 标签匹配选择表达式 o 的值，如果该值与模式匹配。(为了简洁起见，我们已经演示了一个 switch 表达式，但本可以演示一个 switch 语句;switch 块，包括 case 标签，将保持不变。)

这段代码的目的更清晰，因为我们使用了正确的控制结构:我们说，"参数 o 最多匹配以下条件之一，找出它并计算相应的分支。"，并且它是可优化的;在这种情况下，我们更有可能在 O(1) 时间内执行完成。

[[java-17-feature-switch-null]]
=== 模式匹配和 null 值

通常，switch 语句和表达式在选择表达式的值为 `null` 时抛出 `NullPointerException`，所以 `null` 的测试必须在 `switch` 之外进行:

[source,java]
----
static void testFooBar(String s) {
    if (s == null) {
        System.out.println("oops!");
        return;
    }
    switch (s) {
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
    }
}
----

当 switch 只支持少数引用类型时，这是合理的。但是，如果 switch 允许任何类型的选择表达式，并且 case 标签可以有类型模式，那么单独的 `null` 测试感觉就很随意，并且有可能带来不必要的错误。最好将 `null` 测试集成到 switch 中:

[source,java]
----
static void testFooBar(String s) {
    switch (s) {
        case null         -> System.out.println("Oops");
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
    }
}
----

当选择器表达式的值为 `null` 时，switch 的行为由它的 case 标签决定的。case 为 `null`(或 total 类型模式;参见下面的 <<java-17-feature-switch-description-switch-null-matching,4a>>) switch 执行与该标签相关联的代码;如果 case 没有 `null`，switch 会抛出 `NullPointerException`，就像之前一样。(为了保持与 switch 当前语义的向后兼容性，默认标签不匹配 `null` 选择器。)

我们可能希望以与另一个 case 标签相同的方式处理 `null`。例如，在下面的代码中，case `null`, String s 将匹配 null 值和所有的String 值:

[source,java]
----
static void testStringOrNull(Object o) {
    switch (o) {
        case null, String s -> System.out.println("String: " + s);
    }
}
----

[[java-17-feature-switch-refining]]
=== switch 模式改进

在 switch 中对模式的试验表明，想要改进模式是很常见的。考虑以下转换 `Shape` 值的代码:

[source,java]
----
class Shape {}
class Rectangle extends Shape {}
class Triangle  extends Shape { int calculateArea() { ... } }

static void testTriangle(Shape s) {
    switch (s) {
        case null:
            break;
        case Triangle t:
            if (t.calculateArea() > 100) {
                System.out.println("Large triangle");
                break;
            }
        default:
            System.out.println("A shape, possibly a small triangle");
    }
}
----

这段代码为三角形面积大于 100 进行特殊处理，其他的提供一种默认行为。我们不能直接使用单个条件来表示这一点，所有，我们首先要编写一个 case 语句来匹配所有的三角形，然后将三角形面积的判断放在相应的语句中，然后，当三角形面积小于 100 时，我们使用 fall-through 机制获取正确的行为（请注意，break 语句在 if 内）

这里的问题是，只判断一种情况不能使用一条语句。所有，我们需要某种方式对模式进行细化。一种方法可能是允许对 case 语句进行细化;这种改进在其他编程语言中称为 guard 。例如，我们可以引入一个新的关键字，出现在 case 语句的末尾，后面跟一个布尔表达式，例如，`case Triangle t where t.calculateArea() > 100`。

然而，还有一种更具表现力的方法。我们可以扩展模式本身的语言，而不是扩展 case 语句的功能。我们可以添加一种新的模式，称为 guarded pattern（保护模式）(例如 p && b,)，它允许 p 被任意布尔表达式 b 匹配

使用这种方法，我们可以重新编写 `testTriangle` 代码，直接表达大三角形的特殊情况。这就消除了 switch 语句中 fall-through 的使用，这意味着我们可以享受简洁的箭头风格(->)规则:

[source,java]
----
static void testTriangle(Shape s) {
    switch (s) {
        case Triangle t && (t.calculateArea() > 100) ->
            System.out.println("Large triangle");
        default ->
            System.out.println("A shape, possibly a small triangle");
    }
}
----

s 的值匹配 Triangle t && (t.calculateArea() > 100)，首先，它匹配类型 Triangle t，如果是，表达式 `t.calculateArea() > 100` 的计算结果为 `true`。

使用 Switch 可以轻松的更改需求变更时的 case 语句 。例如，我们可能想要将三角形从默认路径中分离出来;如下:

[source,java]
----
static void testTriangle(Shape s) {
    switch (s) {
        case Triangle t && (t.calculateArea() > 100) ->
            System.out.println("Large triangle");
        case Triangle t ->
            System.out.println("Small triangle");
        default ->
            System.out.println("Non-triangle");
    }
}
----

[[java-17-feature-switch-description]]
=== 描述

我们用两种方式增强 switch 语句和表达式

* 扩展 case 语句以包括常量之外的模式
* 介绍两种新的模式:保护模式和括号模式

[[java-17-feature-switch-description-switch]]
==== switch 语句模式

引入一个新的 case p switch 语句，其中 p 是一个模式。但是，switch 的本质没有改变:选择器表达式的值与 switch 语句进行比较，选择其中一个标签，并执行与该标签相关的代码。现在的区别是，对于带有模式的 case 语句，是由模式匹配决定的，而不是由等式检查决定的。例如，在下面的代码中，o 的值匹配模式 Long l，与 case Long l 关联的代码将被执行:

[source,java]
----
Object o = 123L;
String formatted = switch (o) {
    case Integer i -> String.format("int %d", i);
    case Long l    -> String.format("long %d", l);
    case Double d  -> String.format("double %f", d);
    case String s  -> String.format("String %s", s);
    default        -> o.toString();
};
----

当 case 语句可以使模式时，有四个主要的设计问题:

. 增强类型检查
. switch 表达式和语句的完整性
. 模式变量的作用域
. 处理 null

[[java-17-feature-switch-description-switch-enhanced]]
===== 1、增强类型检查

[[java-17-feature-switch-description-switch-typing]]
====== 1a. 表达式类型

在 switch 中支持模式意味着我们可以放松当前对选择器表达式类型的限制。目前，普通的 switch 选择器表达式的类型必须是整数元类型 (char, byte, short, 或 int) 对应的包装类型  (Character, Byte, Short, 或 Integer)， String 或 enum 类型。扩展后，要求选择器表达式的类型为整型元类型或任何引用类型。

例如，在下面的 switch 语句中，选择器表达式 o 与 class 类型、enum 类型、record 类型和 array 类型匹配，包括(以及一个 null 和一个默认值):

[source,java]
----
record Point(int i, int j) {}
enum Color { RED, GREEN, BLUE; }

static void typeTester(Object o) {
    switch (o) {
        case null     -> System.out.println("null");
        case String s -> System.out.println("String");
        case Color c  -> System.out.println("Color with " + Color.values().length + " values");
        case Point p  -> System.out.println("Record class: " + p.toString());
        case int[] ia -> System.out.println("Array of ints of length" + ia.length);
        default       -> System.out.println("Something else");
    }
}
----

`switch` 块中的每个 case 语句必须与选择器表达式兼容。对于带有模式的 case 语句，我们称之为模式标签，我们使用了表达式与模式兼容的现有概念( https://docs.oracle.com/javase/specs/jls/se16/html/jls-14.html#jls-14.30.1[JLS §14.30.1])。

[[java-17-feature-switch-description-switch-Dominance]]
====== 1b. 模式标签的优势

选择器表达式可以匹配一个 switch 块中的多个 case 语句。考虑这个有问题的例子:

[source,java]
----
static void error(Object o) {
    switch(o) {
        case CharSequence cs ->
            System.out.println("A sequence of length " + cs.length());
        case String s ->    // Error - pattern is dominated by previous pattern
            System.out.println("A string: " + s);
        default -> {
            break;
        }
    }
}
----

第一个 case CharSequence cs 优于第二个 case String s，因为每个匹配 String s 的值也匹配 CharSequence cs，但反之不一样。这是因为第二个 String 的类型是第一个 CharSequence 的类型的子类。

形式为 case p 的模式语句，其中 p 是选择器表达式类型的 total  模式优于 case null。这是因为 total 模式匹配所有值，包括 `null`。

case p 的格式优于 case p && e，也就是说，模式是原始模式的一个被保护的版本。例如，case String s 优于 case String s && s.length() > 0，因为每个匹配 String s && s.length() > 0 的值也会匹配 String s。

[[java-17-feature-switch-description-switch-completeness]]
===== 2、switch 表达式和语句的完整性

switch 表达式要求选择器表达式的所有可能值都在 switch 块中处理。这将维护 switch 表达式的成功求值始终会产生一个值的属性。对于普通的 switch 表达式，这是通过 switch 块上一组相当简单的额外条件来实现的。对于 switch 表达式，我们定义了 switch 块的类型覆盖的概念。

[source,java]
----
static int coverage(Object o) {
    return switch (o) {         // Error - incomplete
        case String s  -> s.length();
        case Integer i -> i;
    };
}
----

这个 switch 块的类型覆盖是它的两个箭头规则覆盖的联合。换句话说，类型覆盖是 String 的所有子类型的集合和 Integer 的所有子类型的集合。但是，类型覆盖仍然不包括选择器表达式的类型，因此这个表达式也是不完整的，并会导致编译时错误。

default 的类型覆盖是所有类型，所以这个例子(终于!)是合法的:

[source,java]
----
static int coverage(Object o) {
    return switch (o) {
        case String s  -> s.length();
        case Integer i -> i;
        default -> 0;
    };
}
----

如果选择器表达式的类型是一个密封类( https://openjdk.java.net/jeps/409[JEP 409])，那么类型覆盖检查可以考虑密封类的 permit 子句，以确定 switch 块是否完整。考虑下面这个密封接口 S 的例子，它有三个允许的子类 A、B 和 C:

[source,java]
----
sealed interface S permits A, B, C {}
final class A implements S {}
final class B implements S {}
record C(int i) implements S {}  // Implicitly final

static int testSealedCoverage(S s) {
    return switch (s) {
        case A a -> 1;
        case B b -> 2;
        case C c -> 3;
    };
}
----

编译器可以确定 switch 块的类型覆盖是 A、B 和 C。因为选择器表达式的类型 S 是一个密封的接口，它允许的子类正是 A、B 和 C，所以这个 switch 块是完整的。因此，不需要 default 子句。

为了防止不兼容的单独编译，编译器会自动添加一个默认标签，其代码会抛出一个 `IncompatibleClassChangeError`。只有当密封的接口被更改并且 switch 代码没有被重新编译时，才会到达这个语句。实际上，编译器会为您强化代码。

switch 表达式的完整性的要求类似于选择器表达式是 enum 类的 switch 表达式的处理，如果 enum 类的每个常量都有子句，则不需要 default 子句。

让编译器验证 switch 表达式是否完整是非常有用的。我们将这种检查方法扩展到 switch 语句，而不是只对 switch 表达式进行检查。出于向后兼容性的原因，所有现有的 switch 语句都将不加修改地编译。但是，如果 switch 语句使用了本 JEP 中详细介绍的任何新特性，那么编译器将检查它是否完成。

更准确地说，对于使用模式或 `null` 标签的 switch 语句，或者选择器表达式不是传统类型 (char, byte, short, int, Character, Byte, Short, Integer, String, or an enum type) 的 switch 语句，要求完整性。

这意味着 switch 表达式和 switch 语句现在都可以获得更严格的类型检查的好处。例如:

[source,java]
----
sealed interface S permits A, B, C {}
final class A implements S {}
final class B implements S {}
record C(int i) implements S {}  // Implicitly final

static void switchStatementComplete(S s) {
    switch (s) {    // Error - incomplete; missing clause for permitted class B!
        case A a :
            System.out.println("A");
            break;
        case C c :
            System.out.println("B");
            break;
    };
}
----

要完成大多数 switch 语句，只需在 switch 语句体的末尾添加一个简单的 default 子句。这样可以更清晰、更容易地验证代码。例如，下面的 switch 语句是不完整的，是错误的:

[source,java]
----
Object o = ...
switch (o) {    // Error - incomplete!
    case String s:
        System.out.println(s);
        break;
    case Integer i:
        System.out.println("Integer");
        break;
}
----

改进为完整的:

[source,java]
----
Object o = ...
switch (o) {
    case String s:
        System.out.println(s);
        break;
    case Integer i:
        System.out.println("Integer");
        break;
    default:    // Now complete!
        break;
}
----

可能的情况是，Java 语言的未来编译器会对不完整的遗留 switch 语句发出警告。

[[java-17-feature-switch-description-switch-scope]]
===== 3、模式变量的作用域

模式变量( https://openjdk.java.net/jeps/394[JEP 394] )是模式声明的局部变量。模式变量声明的不同寻常之处在于它们的作用域是对流敏感的。回顾一下下面的例子，其中 String s 声明了模式变量 s:

[source,java]
----
static void test(Object o) {
    if ((o instanceof String s) && s.length() > 3) {
        System.out.println(s);
    } else {
        System.out.println("Not a string");
    }
}
----

s 的声明在 && 表达式的右边和 then 块的作用域中。但是，它不在 "else" 块的作用域中;为了将控制转移到 “else” 块，模式匹配必须失败，在这种情况下，模式变量将没有被初始化。

我们扩展了模式变量声明作用域这个对流敏感的概念，用两个新规则来包含 case 标签中出现的模式声明:

. 在 switch 的 case 语句中的模式变量的作用域包括出现在箭头右侧的表达式、block 或 throw 语句。
. 模式变量声明的作用域出现在 switch 标签语句组的 case 标签中，在这个 case 标签中没有后面的 switch 标签，它包括语句组的块语句。

下面的例子展示了第一条规则:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case Character c -> {
            if (c.charValue() == 7) {
                System.out.println("Ding!");
            }
            System.out.println("Character");
        }
        case Integer i ->
            throw new IllegalStateException("Invalid Integer argument of value " + i.intValue());
        default -> {
            break;
        }
    }
}
----

变量 c 的作用域是第一个箭头右边的块。

变量 i 的作用域是第二个箭头右边的 throw 语句。

第二条规则更为复杂。让我们首先考虑一个例子，其中 switch 语句组只有一个 case 字句:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case Character c:
            if (c.charValue() == 7) {
                System.out.print("Ding ");
            }
            if (c.charValue() == 9) {
                System.out.print("Tab ");
            }
            System.out.println("character");
        default:
            System.out.println();
    }
}
----

变量 c 的作用域包括语句组中的所有语句，即两个 if 语句和 println 语句。这个作用域不包括 default 组的语句。

必须排除通过声明模式变量的 case 标签出现编译时错误的可能性。看看这个错误的例子:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case Character c:
            if (c.charValue() == 7) {
                System.out.print("Ding ");
            }
            if (c.charValue() == 9) {
                System.out.print("Tab ");
            }
            System.out.println("character");
        case Integer i:                 // Compile-time error
            System.out.println("An integer " + i);
        default:
            break;
    }
}
----

假设这种写法没有问题，并且选择器表达式 o 的值是一个字符，那么 switch 块在执行到 case Integer i:，其中变量 i 将不会被初始化。因此，允许执行以声明变量的 case 字句是一个编译时错误。

这就是为什么 case Character c: case Integer i: ...  是不允许的。类似的推理也适用于禁止 case 字句中的多个模式: case Character c, Integer i: ... 或 case Character c, Integer i -> ... 是不被允许的。如果允许这样的 case 字句，那么 c 和 i 都将在冒号或箭头之后的作用域内，但是 c 和 i 中只有一个会被初始化，这取决于 o 的值是字符还是整数。

另一方面，通过一个没有声明模式变量的子句是安全的，正如下面的例子所示:

[source,java]
----
void test(Object o) {
    switch (o) {
        case String s:
            System.out.println("A string");
        default:
            System.out.println("Done");
    }
}
----

[[java-17-feature-switch-description-switch-null]]
===== 4、处理 null

[[java-17-feature-switch-description-switch-null-matching]]
====== 4a 匹配 null

通常，如果选择器表达式的计算结果为 null, switch 会抛出 NullPointerException。这是很容易理解的行为，我们不建议为任何现有的 switch 代码更改它。

然而，考虑到模式匹配和空值有一个特殊的语义，在保持与现有 switch 语义兼容的同时，有机会使模式切换对 null 更加友好。

首先，我们为 case 引入了一个新的 null 标签，当选择器表达式的值为 null 时，它会明显匹配。

其次，我们观察到，如果选择器表达式的类型为 total 的模式出现了 case 标签，那么当选择器表达式的值为 null 时，该标签也将匹配。

NOTE:: 类型 U 的类型模式 p 对于类型 T 是 total，如果 T 是 U 的子类型。例如，类型模式对象 o 对于类型 String 是 total。

如果选择器表达式的值为 null，switch 会立即抛出 NullPointerException。相反，我们检查 case 标签来确定 switch 的行为:

* 如果选择器表达式的计算结果为 null，则表示匹配任何 null case 或 total 模式 case 。如果没有这样的标签与 switch 块相关联，那么 switch 抛出 NullPointerException，就像之前一样。
* 如果选择器表达式的计算结果为一个非空值，那么我们将一如既往地选择一个匹配的 case 标签。如果没有 case 标签匹配，则认为匹配所有匹配标签。

例如，给定下面的声明，求值 test(null) 将输出 null! 而不是抛出 NullPointerException:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case null     -> System.out.println("null!");
        case String s -> System.out.println("String");
        default       -> System.out.println("Something else");
    }
}
----

这个关于 null 的新行为就好像编译器自动用一个 case null 来丰富 switch 块，它的 body 抛出 `NullPointerException`。换句话说，这段代码:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case String s  -> System.out.println("String: " + s);
        case Integer i -> System.out.println("Integer");
        default  -> System.out.println("default");
    }
}
----

等价于

[source,java]
----
static void test(Object o) {
    switch (o) {
        case null      -> throw new NullPointerException();
        case String s  -> System.out.println("String: "+s);
        case Integer i -> System.out.println("Integer");
        default  -> System.out.println("default");
    }
}
----

在这两个例子中，求值 `test(null)` 将导致抛出 `NullPointerException`。

我们保留了现有 switch 结构的直觉，即执行对 null 的匹配是一件特殊的事情。模式 switch 的不同之处在于，你有一个机制可以直接在 switch 内部而不是外部处理这种情况。如果你选择在一个 switch 块中没有匹配 null 的 case 标签，那么 switch 一个 null 值将抛出 `NullPointerException`，就像之前一样。

[[java-17-feature-switch-description-switch-null-forms]]
====== 4b New label forms arising from null labels

JDK 16 中的 Switch 块支持两种风格:一种基于标记的语句组 (the : form) ，它可能出现 fall-through;另一种单一随后形式(the -> form)，它不可能出现 fall-through。在前一种风格中，多个标签通常写成 case l1: case l2:，而在后一种风格中，多个标签写成 case l1, l2:。

支持 null 标签意味着许多特殊情况可以用 : form 表示。例如:

[source,java]
----
Object o = ...
switch(o) {
    case null: case String s:
        System.out.println("String, including null");
        break;
    ...
}
----

我们期望 : 和 -> 都应该具有相同的表达性，如果前一种风格支持 情况A:情况B:，那么后一种风格应该支持 情况A, B ->。因此，前面的例子表明，我们应该支持 case null, String s -> 标签，如下所示:

[source,java]
----
Object o = ...
switch(o) {
    case null, String s -> System.out.println("String, including null");
    ...
}
----

当它是 null 引用或字符串时，o 的值匹配这个标签。在这两种情况下，变量 s 都用 o 的值初始化。

(反过来的形式，case String s, null 也应该被允许，并且行为相同。)

将 null case 与 default 标签结合使用也是有意义的(而且并不少见)，例如:

[source,java]
----
Object o = ...
switch(o) {
    ...
    case null: default:
        System.out.println("The rest (including null)");
}
----

同样，应该以 -> 形式支持这一点。为此，我们引入了一个新的 default case 标签:

[source,java]
----
Object o = ...
switch(o) {
    ...
    case null, default ->
        System.out.println("The rest (including null)");
}
----

o 的值匹配这个标签，如果它是 null 引用值，或者没有其他标签匹配。

[[java-17-feature-switch-guarded]]
==== 保护模式和括号模式

在成功的模式匹配之后，我们通常会进一步测试匹配的结果。这可能会导致繁琐的代码，例如:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case String s:
            if (s.length() == 1) { ... }
            else { ... }
            break;
        ...
    }
}
----

所需要的测试— o 是长度为 1 的字符串—不幸地被分割为 case 标签和随后的 if 语句。如果 switch 模式支持 case 标签中的模式和布尔表达式的组合，我们可以提高可读性。

我们不是添加另一个特殊的 case 标签，而是通过添加保护模式(p && e)来增强模式语言。这允许重写上面的代码，以便所有的条件逻辑都被提升到 case 标签中:

[source,java]
----
static void test(Object o) {
    switch (o) {
        case String s && (s.length() == 1) -> ...
        case String s                      -> ...
        ...
    }
}
----

如果 o 是字符串且长度为 1，则第一个 case 匹配。如果 o 是一个其他长度的字符串，则第二种情况匹配。

有时我们需要将模式括起来以避免解析歧义。因此，我们扩展了模式语言以支持(p)编写的带括号的模式，其中 p 是一种模式。

更准确地说，我们改变了模式的语法。假设添加了 JEP 405 的记录模式和数组模式，模式语法将变为:

[source,java]
----
Pattern:
  PrimaryPattern
  GuardedPattern

GuardedPattern:
  PrimaryPattern && ConditionalAndExpression

PrimaryPattern:
  TypePattern
  RecordPattern
  ArrayPattern
----

一个被保护的模式是p && e的形式，其中p是一个模式，e是一个布尔表达式。在被保护的模式中，任何使用但没有在子表达式中声明的局部变量、形式参数或异常参数都必须是final或有效final。

一个被保护的模式p && e引入了模式p和表达式e引入的模式变量的并集。在p中任何模式变量声明的范围都包括表达式e。这允许像String s && (s.length() > 1)这样的模式，它匹配一个可以转换为String的值，这样该字符串的长度大于1。

一个值匹配一个被保护的模式p && e，首先，它匹配模式p，然后，表达式e的计算结果为true。如果值与p不匹配，则不会尝试对表达式e求值。

带括号的模式的形式是(p)，其中p是模式。圆括号中的模式(p)引入了由子模式p引入的模式变量。如果匹配模式p，值就匹配圆括号中的模式(p)。

例如，我们还将表达式的语法改为:

[source,java]
----
InstanceofExpression:
  RelationalExpression instanceof ReferenceType
  RelationalExpression instanceof PrimaryPattern
----

这个更改，以及保护模式语法规则中的非终结符ConditionalAndExpression，确保，例如，表达  e instanceof String s && s.length() > 1 继续明确解析表达式 (e instanceof String s) && (s.length() > 1)。如果 && 旨在保护模式的一部分,那么整个模式应该括号,例如,e instanceof (String s && s.length() > 1).

在语法规则中为保护模式使用非终结符ConditionalAndExpression还消除了另一个关于带有保护模式的case标签的潜在歧义。例如:

[source,java]
----
boolean b = true;
switch (o) {
    case String s && b -> s -> s;
}
----

如果一个被保护模式的保护表达式被允许为任意表达式，那么第一个出现的 -> 是 lambda 表达式的一部分还是 switch 规则的一部分(switch 规则的主体是 lambda 表达式)就会出现歧点。由于 lambda 表达式永远不可能是一个有效的布尔表达式，因此可以安全地限制保护表达式的语法。

[[java-17-feature-rmi]]
== 删除 RMI Activation

将删除远程方法调用 (RMI) 激活机制，但应保留 RMI 的其余部分。RMI 激活机制已变得多余，不再使用。Java SE 15 中的 JEP 385 弃用了它并建议将其删除。

[[java-17-feature-sealed]]
== 密封类 (预览)

[[java-17-feature-sealed-summary]]
=== 简介

通过密封的类和接口来增强 Java 编程语言，这是新的预览特性。https://cr.openjdk.java.net/~briangoetz/amber/datum.html[密封类和接口] 可以阻止其他类或接口扩展或实现它们。

[[java-17-feature-sealed-history]]
=== 历史

密封类由 https://openjdk.java.net/jeps/360[JEP 360] 提出，并在 <<java-15-feature-sealed,JDK 15>> 中作为一个预览特性发布。

JEP 397 对它们进行了进一步的改进，并在 JDK 16 中作为预览特性发布。本 JEP 建议将 JDK 17 中的 Sealed Classes 定型，与 JDK 16 没有任何变化。

[[java-17-feature-sealed-goals]]
=== 目标

* 允许类或接口的作者可以控制实现该代码的代码。
* 提供比访问修饰符更具声明性的方式来限制超类的使用。
* 通过支持对模式的详尽分析而支持模式匹配的未来发展。

[[java-17-feature-sealed-non-goals]]
=== 非目标实现

* 不提供新形式的访问控制。
* 不以任何方式改变 final 。

[[java-17-feature-sealed-motivation]]
=== 动机

在现代应用对真实世界进行数据建模时，具有类和接口继承关系的面向对象数据模型已被证明是非常有效的，而这也是 java 语言的一种重要表现形式。

然而，在某些情况下，这种表达可以被驯服的。例如，Java 支持使用枚举类来创建具有固定数量的实例的情况。如下代码，枚举类给出了一组固定的行星，他们是类的唯一值。因此，你可以随意的切换他们，而不需要编写子句。

[source,java]
----
enum Planet { MERCURY, VENUS, EARTH }

Planet p = ...
switch (p) {
  case MERCURY: ...
  case VENUS: ...
  case EARTH: ...
}
----

使用枚举对于具有固定数量的值时很有用，但有时我们想要创建一组具有固定类型的值。这时，我们可以通过类层次结构来实现这一点。这并不是将其作为代码继承和重用的机制，而是将其作为一种列出各种值的一种方法。如上示例，我们可以将 天文领域的各种值建模如下：

[source,java]
----
interface Celestial { ... }
final class Planet implements Celestial { ... }
final class Star   implements Celestial { ... }
final class Comet  implements Celestial { ... }
----

然而，这个层次结构并没有反映出重要的领域知识，即在我们的模型中只有三种天体。在这些情况下，限制子类或子接口的集合可以简化建模。

考虑另外一个例子，例如，在图形库中，`Shape` 类的作者可能希望只有特定的类才能扩展 `Shape`，因为该库的许多工作都涉及到如何以适当的方式处理各种形状。 作者只对 `Shape` 的已知子类感兴趣，而对 `Shape` 的未知子类的代码不感兴趣。
在这种情况下，目标并不是允许任意的类扩展 `Shape`，从而继承其代码以供重用。 不幸的是，Java 之前始终以代码重用始终作为目标: 如果 `Shape` 可以完全扩展，则可以扩展任何数量的类。
现在放宽此目标，使作者可以声明一个类别层次结构，该层次结构对于任意类都不是可扩展的。 在这样一个密闭的类层次结构中，代码重用仍然是可能的，但不能超出范围。

Java 开发人员熟悉限制子类集合的思想，因为它经常出现在 API 设计中。该语言在这方面提供了有限的工具:要么使一个类为 `final`，这样它就没有子类;要么使一个类或它的构造函数为 `package-private`，这样它就只能在同一个包中有子类。 https://hg.openjdk.java.net/jdk/jdk/file/tip/src/java.base/share/classes/java/lang/[JDK 中] 出现了一个 `package-private` 超类的示例

[source,java]
----
package java.lang;

abstract class AbstractStringBuilder {...}
public final class StringBuffer  extends AbstractStringBuilder {...}
public final class StringBuilder extends AbstractStringBuilder {...}
----

如果这个类的目标是代码重用时，例如 `AbstractStringBuilder` 的子类要添加共享代码时， `package-private` 方法很有用。然而，当目标是建模时，这种方法是无用的，因为用户代码无法访问关键抽象——超类——来切换它(因为有可能不属于同一个包)。
允许用户访问超类而不允许他们扩展它是不可能的。(即使在声明了 `Shape` 及其子类的图形库中，如果只有一个包可以访问 `Shape`，那就太不幸了。)

总之，超类应该是可以被广泛访问的(因为它代表了用户的一个重要抽象)，但不能被广泛扩展(因为它的子类应该被限制为作者所知道的)。这样的超类应该能够表示它是与一组给定的子类共同开发的，既可以为读者记录意图，也可以允许 Java 编译器执行。
同时，超类不应该过分地约束它的子类，例如，强迫它们为 `final` 或者阻止它们定义自己的状态。

[[java-17-feature-sealed-description]]
=== 描述

一个密封的类或接口只能由那些允许的类和接口来扩展或实现。

通过将 `sealed` 修饰符应用到类的声明，这样的类叫密封类。
然后，在任何 `extends` 和 `implements` 子句之后，声明 `permits` 子句指定允许扩展密封类的类。例如，下面的 `Shape`  指定了三个允许的子类

[source,java]
----
package com.example.geometry;

public abstract sealed class Shape
    permits Circle, Rectangle, Square {...}
----

上面 `permits` 指定的类必须位于超类附近:要么在同一个模块中(如果超类在一个命名的模块中)，要么在同一个包中(如果超类在一个未命名的模块中)。
例如，在下面的 `Shape` 中，它允许的子类都位于同一个命名模块的不同包中

[source,java]
----
package com.example.geometry;

public abstract sealed class Shape
    permits com.example.polar.Circle,
            com.example.quad.Rectangle,
            com.example.quad.simple.Square {...}
----

当允许的子类在大小和数量上都比较小时，在与 `sealed` 类中声明它们可能比较方便。当在这种情况下声明它们时，密封类可能会省略 `permits`  子句，Java 编译器将从源文件(可能是辅助类或嵌套类)的声明中推断允许的子类。
例如，如果 `Root ` 找到以下代码。然后密封类 `Root ` 被推断为有三个允许的子类

[source,java]
----
abstract sealed class Root { ...
    final class A extends Root { ... }
    final class B extends Root { ... }
    final class C extends Root { ... }
}
----

由 permit 指定的类必须具有规范名称，否则将报告编译时错误。这意味着匿名类和局部类不允许是密封类的子类型。

密封类对其允许的子类(由其 `permits` 子句指定的类)施加三个约束:

. 密封类及其允许的子类必须属于同一个模块，如果在未命名的模块中声明，则属于同一个包。
. 每个允许的子类都必须直接扩展密封类。
. 每个被允许的子类必须选择以下三个修饰符之一来描述它如何继超类之后的行为

* 可以将允许的子类声明为 `final`，以防止其在类层次结构中的进一步扩展。
* 可以将允许的子类声明为 `sealed` ，以允许其层次结构的一部分扩展到其密封的超类所设想的范围之外，但以受限的方式。
* 可以将允许的子类声明为 `non-sealed` ，以便其层次结构的一部分恢复为可供未知子类扩展的状态。 (密封类不能阻止其允许的子类这样做。)

作为三个约束的示例，Circle 和 Square 是 `final` 的，而 Rectangle 是 `sealed`，我们添加了一个 `non-sealed` 的新子类，WeirdShape：:

[source,java]
----
package com.example.geometry;

public abstract sealed class Shape
    permits Circle, Rectangle, Square, WeirdShape { ... }

public final class Circle extends Shape { ... }

public sealed class Rectangle extends Shape
    permits TransparentRectangle, FilledRectangle { ... }
public final class TransparentRectangle extends Rectangle { ... }
public final class FilledRectangle extends Rectangle { ... }

public final class Square extends Shape { ... }

public non-sealed class WeirdShape extends Shape { ... }
----

即使 `WeirdShape` 是可以进行扩展的，那些子类的所有实例也是 `WeirdShape` 的实例。因此，用来测试 Shape 的实例是否为圆形、矩形、正方形或 WeirdShape 的代码仍然是详尽的。

每个允许的子类必须使用一个且只有一个修饰符 `final`、`sealed` 和 `non-sealed`。一个类不可能同时是 `sealed`(意味着有限制性的子类)和 `final`(意味着没有子类)，或者同时是  `non-sealed` (意味着没有限制性的子类)和 `final` (意味着没有子类)，或者同时是 `sealed`(意味着有限制性的子类)和 `non-sealed`(意味着没有限制性的子类)。

(可以将 `final` 修饰符视为一种 `sealed` 的增强形式，其中完全禁止扩展/实现。也就是说，`final` 在概念上等同于 `sealed` +一个未指定任何内容的 `permits` 子句；请注意，此类 `permits` 子句不能用 Java 编写 )

一个 `sealed` 或 `non-sealed` 可以是抽象的，并且具有抽象成员。一个 `sealed` 类可以允许抽象的子类(如果它们是 `sealed` 的或 `non-sealed` 的，而不是 `final` 的)。如果任何类扩展了一个密封类，但不允许这样做，则会出现编译时错误。

[[java-17-feature-sealed-description-accessibility]]
==== 类的可访问性

因为 `extends` 和 `permits`  子句使用类名，所以允许的子类和它的密封超类必须可以相互访问。但是，允许的子类之间不需要具有与其他类或密封类相同的可访问性。
特别是，一个子类可能比密封类更难访问;这意味着，在将来的版本中，当模式匹配支持 `switches` 时，一些用户将无法完全切换子类，除非使用了默认子句(或其他 total 模式)。Java 编译器检测机制并不如用户想象的那么详尽，建议使用 `default`  子句并自定义错误消息。

[[java-17-feature-sealed-description-interface]]
==== 密封接口

与类的情况类似，通过对接口应用 `sealed` 修饰符来密封接口。在任何用于指定超接口的 `extends` 子句之后，使用 `permits`  子句指定实现类和子接口。例如，上面的行星例子可以重写如下:

[source,java]
----
sealed interface Celestial
    permits Planet, Star, Comet { ... }

final class Planet implements Celestial { ... }
final class Star   implements Celestial { ... }
final class Comet  implements Celestial { ... }
----

下面是类层次结构的另一个经典例子，其中有一组已知的子类:数学表达式建模。

[source,java]
----
package com.example.expression;

public sealed interface Expr
    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr { ... }

public final class ConstantExpr implements Expr { ... }
public final class PlusExpr     implements Expr { ... }
public final class TimesExpr    implements Expr { ... }
public final class NegExpr      implements Expr { ... }
----

[[java-17-feature-sealed-description-records]]
==== 密封类和 Records

密封类与 https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10[Records 类] (http://openjdk.java.net/jeps/384[JEP 384])一起工作得很好。Records 默认是 `final` 的，因此带有 Records 的密封类层次结构比上面的示例稍微简洁一些

[source,java]
----
package com.example.expression;

public sealed interface Expr
    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr {...}

public record ConstantExpr(int i)       implements Expr {...}
public record PlusExpr(Expr a, Expr b)  implements Expr {...}
public record TimesExpr(Expr a, Expr b) implements Expr {...}
public record NegExpr(Expr e)           implements Expr {...}
----

密封类和 Records 的组合有时称为 https://en.wikipedia.org/wiki/Algebraic_data_type[algebraic data types]: Records 允许我们表达产品类型，密封类允许我们表达类型数量。

[[java-17-feature-sealed-description-conversions]]
==== 密封类转换

强制转换表达式将值转换为类型。类型 instanceof 表达式根据类型测试值。Java 对这类表达式中允许的类型非常宽容。例如:

[source,java]
----
interface I {}
   class C {} // does not implement I

   void test (C c) {
       if (c instanceof I)
           System.out.println("It's an I");
   }
----

这个程序是合法的，尽管目前 C 对象没有实现接口 I。当然，随着程序的发展，它可能是:

[source,java]
----
...
class B extends C implements I {}

test(new B());
// Prints "It's an I"
----

类型转换规则捕获了开放可扩展性的概念。Java 类型系统不假设一个封闭的世界。类和接口可以在将来扩展，并将转换转换编译为运行时测试，因此我们可以安全灵活地进行转换。

然而，在范围的另一端，转换规则确实解决了类绝对不能扩展的情况，即当它是最终类时。

[source,java]
----
interface I {}
final class C {}

void test (C c) {
    if (c instanceof I)     // Compile-time error!
        System.out.println("It's an I");
}
----

方法测试编译失败，因为编译器知道不可能有 C 的子类，所以由于 C 没有实现 I，那么 C 值永远不可能实现 I。这是一个编译时错误。

如果 C 不是 final 的，而是 sealed 的呢? 它的直接子类是显式枚举的，并且——根据被密封的定义——在同一个模块中，所以我们希望编译器查看它是否能发现类似的编译时错误。考虑以下代码:

[source,java]
----
interface I {}
   sealed class C permits D {}
   final class D extends C {}

   void test (C c) {
       if (c instanceof I)
           System.out.println("It's an I");
   }
----

类 C 没有实现 I，也不是 final，因此根据现有的规则，我们可以得出这样的结论:转换是可能的。然而，C 是密封的，并且 C 有一个直接子类 D。根据密封类型的定义，D 必须是 final、sealed, 或 non-sealed 的。在这个例子中，C 的所有直接子类都是 final 类，不实现 I。因此这个程序应该被拒绝，因为不可能有实现 I 的 C 的子类型。

相反，考虑一个类似的程序，其中一个密封类的直接子类是非密封的:

[source,java]
----
interface I {}
   sealed class C permits D, E {}
   non-sealed class D extends C {}
   final class E extends C {}

   void test (C c) {
       if (c instanceof I)
           System.out.println("It's an I");
   }
----

这是类型正确的，因为非密封类型 D 的子类型可以实现 I。

这个 JEP 将扩展缩小引用转换的定义，以密封的层次结构，从而在编译时确定哪些转换是不可能的。

[[java-17-feature-sealed-description-jdk]]
==== 在 JDK 中 密封类

关于如何在 JDK 中使用密封类的一个例子是在 `java.lang.constant` 包中，该包为 https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/constant/package-summary.html[JVM 实体的模型描述符]:

[source,java]
----
package java.lang.constant;

public sealed interface ConstantDesc
    permits String, Integer, Float, Long, Double,
            ClassDesc, MethodTypeDesc, DynamicConstantDesc { ... }

// ClassDesc is designed for subclassing by JDK classes only
public sealed interface ClassDesc extends ConstantDesc
    permits PrimitiveClassDescImpl, ReferenceClassDescImpl { ... }
final class PrimitiveClassDescImpl implements ClassDesc { ... }
final class ReferenceClassDescImpl implements ClassDesc { ... }

// MethodTypeDesc is designed for subclassing by JDK classes only
public sealed interface MethodTypeDesc extends ConstantDesc
    permits MethodTypeDescImpl { ... }
final class MethodTypeDescImpl implements MethodTypeDesc { ... }

// DynamicConstantDesc is designed for subclassing by user code
public non-sealed abstract class DynamicConstantDesc implements ConstantDesc { ... }
----

[[java-17-feature-sealed-description-pattern-matching]]
==== 密封类模式匹配

密封类的一个重要好处将在未来的版本中与模式匹配一起实现。用户代码将能够使用类型测试模式增强的开关，而不是使用 if-else 检查密封类的实例。这将允许 Java 编译器检查模式是否详尽。

例如，考虑前面的这段代码:

[source,java]
----
Shape rotate(Shape shape, double angle) {
    if (shape instanceof Circle) return shape;
    else if (shape instanceof Rectangle) return shape.rotate(angle);
    else if (shape instanceof Square) return shape.rotate(angle);
    // no else needed!
}
----

Java 编译器不能确保 instanceof 测试覆盖 Shape 的所有子类。例如，如果省略了 instanceof Rectangle 测试，则不会发出编译时错误消息。

相反，在下面使用模式匹配开关表达式的代码中，编译器可以确认覆盖了 Shape 的每个允许的子类，因此不需要默认子句(或其他总模式)。此外，如果缺少这三种情况中的任何一种，编译器将发出错误消息:

[source,java]
----
Shape rotate(Shape shape, double angle) {
    return switch (shape) {   // pattern matching switch
        case Circle c    -> c;
        case Rectangle r -> r.rotate(angle);
        case Square s    -> s.rotate(angle);
        // no default needed!
    }
}
----

[[java-17-feature-sealed-description-grammar]]
==== Java 语法

类声明的语法修改如下:

[source,txt]
----
NormalClassDeclaration:
  {ClassModifier} class TypeIdentifier [TypeParameters]
    [Superclass] [Superinterfaces] [PermittedSubclasses] ClassBody

ClassModifier:
  (one of)
  Annotation public protected private
  abstract static sealed final non-sealed strictfp

PermittedSubclasses:
  permits ClassTypeList

ClassTypeList:
----

[[java-17-feature-sealed-description-jvm]]
==== JVM 对密封类的支持

Java 虚拟机在运行时识别密封类和接口，并防止未经授权的子类和子接口进行扩展。

尽管 `sealed` 是类修饰符，但 `ClassFile` 结构中没有 `ACC_SEALED` 标志。 相反，密封类的类文件具有 `PermittedSubclasses` 属性，该属性隐式指示 `sealed` 修饰符，并显式指定允许的子类:

[source,java]
----
PermittedSubclasses_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 number_of_classes;
    u2 classes[number_of_classes];
}
----

允许的子类列表是强制性的，即使编译器推断了允许的子类，这些推断的子类也明确包含在 `PermittedSubclasses` 属性中。

允许的子类的类文件不包含任何新属性。

当 JVM 尝试定义其超类或超接口具有 `PermittedSubclasses` 属性的类时，所定义的类必须由该属性命名。 否则，将引发 `IncompatibleClassChangeError`。

[[java-17-feature-sealed-description-reflection]]
==== Reflection API

以下 `public` 方法将添加到 `java.lang.Class`:

* Class<?>[] getPermittedSubclasses()
* boolean isSealed()

方法 `getPermittedSubclasses()` 返回一个数组，其中包含 `java.lang.constant.Class` 对象，如果该对象是密封类，则表示该类的所有允许的子类；如果不是密封类，则返回一个空数组。

如果给定的类或接口是密封类，则 `isSealed()` 方法将返回 `true`。 (与 isEnum 比较。)

[[java-17-feature-sealed-alternatives]]
=== 备选方案

某些语言直接支持 https://en.wikipedia.org/wiki/Algebraic_data_type[algebraic data types (ADTs)]，例如 Haskell 的数据功能。 可以通过 enum 功能的一种变体，让 Java 开发人员以更熟悉的方式直接地表示 ADT，
在该声明中，可以在一个声明中定义总和。 但是，这将不支持所有期望的用例，例如那些总和超出一个以上编译单元中的类，或者总和超出非乘积类的那些用例。

`permits`  子句允许一个密封类(例如前面显示的 `Shape` 类)可以通过任何模块中的代码进行访问以进行调用，但是只能通过与该密封类(或相同包)相同的模块中的代码来进行实现。
(如果在未命名的模块中)。 这使得类型系统比访问控制系统更具表现力。 仅使用访问控制，如果 `Shape` 可以通过任何模块中的代码进行访问以进行调用(因为已导出其包)，
那么 Shape 也是可以在任何模块中进行实现的访问。 并且，如果 `Shape` 在任何其他模块中均不可访问以实现，则 `Shape` 在任何其他模块中也均不可访问。

[[java-17-feature-sealed-dependencies]]
=== 依赖

密封类并不依赖于 records (http://openjdk.java.net/jeps/384[JEP 384]) 或 模式匹配(https://openjdk.java.net/jeps/375[JEP 375])，相反，它们两者都可以与密封类结合的很好。

[[java-17-feature-jit]]
== 删除实验性 AOT 和 JIT 编译器

删除实验性的基于 Java 的提前 (AOT) 和即时 (JIT) 编译器，因为使用有限，维护它所需的工作量很重要。

即使保留了实验性的 Java 级 JVM 编译器接口 (JVMCI)，这样开发人员也可以继续使用外部构建的编译器版本，并使用 Graal 编译器 ( GraalVM )进行 JIT 编译。

动机：

作为实验性功能，JDK 9 已与提前编译（jaotc 工具）集成。对于 AOT 编译，jaotc 使用 Java 编写的 Graal 编译器。由于这些实验特性尚未使用，因此需要付出相当大的努力来维护和改进它们。Oracle 发布的 JDK 16 版本没有这些功能，也没有人抱怨。

[[java-17-feature-security]]
== 弃用即将删除安全管理器

从 Java 1.0 开始，就有了一个安全管理器。然而，多年来它很少被使用。为了推动 Java 向前发展，安全管理器已在 Java 17 中被弃用，并将在未来版本中与旧 Applet API (JEP 398) 一起删除。

[[java-17-feature-security-goals]]
=== 目标

* 为开发人员在 Java 的未来版本中移除安全管理器做好准备。
* 如果用户的 Java 程序依赖于安全管理器，则发出警报。
* 评估是否需要新的 API 或机制来修复使用安全管理器的独特、有限的用例，例如阻塞 System::exit。

[[java-17-feature-memory]]
== 外部函数和内存 API（孵化器）

引入一个 API，通过有效调用外部函数（即 JVM 外部的代码）和安全地访问外部内存（即不由 JVM 处理的内存），允许 Java 程序调用本地库和处理本地数据而没有 JNI 的风险.

在这个 JEP 提案中，是早期两个孵化 API 的演变：外部内存访问 API 和外部链接器 API。外部内存访问 API 首先由 JEP 370 提出，并于 2019 年底作为 Java 14 的一个孵化 API，它被 Java 15 中的 JEP 383 和 Java 16 中的 JEP 393 重新孵化。Foreign Linker API 最初是由 JEP 389 提出的，目标是在 2020 年底的 Java 16，也是一个孵化 API。

[[java-17-feature-memory-goals]]
=== 目标

易用性：用 Java 本机接口 (JNI) 替换卓越的纯 Java 开发模型。

性能：与现有 API（如 JNI 或 sun.misc.Unsafe）相似的性能，如果不是更好的话。表现。

常规：提供了在各种类型的外部内存（例如，本机内存、持久内存和堆内存）上工作的方法，并随着时间的推移适应其他平台（例如，x86 32 位）和用 C 以外的语言编写的外部函数（例如，C++、FORTAN）。

安全：仅当应用程序开发人员或最终用户明确选择加入时，才停用默认的不安全操作。

[[java-17-feature-vector]]
== 向量 API (孵化器)

[[java-17-feature-vector-summary]]
=== 简介

该孵化器 API 提供了一个 jdk.incubator.vector 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能。

[[java-17-feature-vector-goal]]
=== 目标

清晰简洁的 API :: API 可以清楚，简洁的表达各种向量计算，这些计算通常由一系列的向量操作组成，这些操作有可能包含循坏，也有可能包含控制流。API 可以表达对向量大小（或每个向量的维数的数量）的通用计算，可以使此类计算能够跨平台的支持不同大小向量的计算（如下个目标所述）。
平台无关:: API 应该和平台架构无关，并且支持在支持向量硬件指令的多核 CPU 架构上运行时实现。As is usual in Java APIs, where platform optimization and portability conflict, the bias will be to making the Vector API portable, even if some platform-specific idioms cannot be directly expressed in portable code. The next goal of x64 and AArch64 performance is representative of appropriate performance goals on all platforms where Java is supported. The ARM Scalable Vector Extension (SVE) is of special interest in this regard to ensure the API can support this architecture, even though as of writing there are no known production hardware implementations.
Reliable runtime compilation and performance on x64 and AArch64 architectures:: The Java runtime, specifically the HotSpot C2 compiler, shall compile, on capable x64 architectures, a sequence of vector operations to a corresponding sequence of vector hardware instructions, such as those supported by Streaming SIMD Extensions (SSE) and Advanced Vector Extensions (AVX) extensions, thereby generating efficient and performant code. The programmer shall have confidence that the vector operations they express will reliably map closely to associated hardware vector instructions. The same shall also apply to capable ARM AArch64 architectures compiling to a sequence of vector hardware instructions supported by Neon.
Graceful degradation:: If a vector computation cannot be fully expressed at runtime as a sequence of hardware vector instructions, either because an architecture does not support some of the required instructions or because another CPU architecture is not supported, then the Vector API implementation shall degrade gracefully and still function. This may include issuing warnings to the developer if a vector computation cannot be sufficiently compiled to vector hardware instructions. On platforms without vectors, graceful degradation shall yield code competitive with manually-unrolled loops, where the unroll factor is the number of lanes in the selected vector.

[[java-17-feature-vector-non-goal]]
=== 非目标

* 增强 HotSpot 中的自动向量化支持并不是目标
* HotSpot 的目标不是在 x64 和 AArch64 之外的 CPU 架构上支持向量硬件指令。这种支持留给以后的 jep。然而，重要的是要声明，正如目标所表达的那样，API 不能排除这样的实现。此外，所执行的工作可能会自然地利用和扩展 HotSpot 中的现有抽象，以获得自动向量化的向量支持，从而使这样的任务变得更容易。
* 在当前或未来的迭代中支持 C1 编译器并不是目标。我们希望在将来的工作中支持 Graal 编译器。
* 它的目标不是支持 Java strictfp 关键字定义的严格浮点计算。对浮点标量进行浮点运算的结果可能与对浮点标量的向量进行等价的浮点运算的结果不同。然而，这一目标并不排除表达或控制浮点向量计算所需的精度或再现性的可能。

[[java-17-feature-vector-motivation]]
=== 动机

Vector computations consist of a sequence of operations on vectors. A vector comprises a (usually) fixed sequence of scalar values, where the scalar values correspond to the number of hardware-defined vector lanes. A binary operation applied to two vectors with the same number of lanes would, for each lane, apply the equivalent scalar operation on the corresponding two scalar values from each vector. This is commonly referred to as Single Instruction Multiple Data (SIMD).

Vector operations express a degree of parallelism that enables more work to be performed in a single CPU cycle and thus can result in significant performance gains. For example, given two vectors each covering a sequence of eight integers (eight lanes), then the two vectors can be added together using a single hardware instruction. The vector addition hardware instruction operates on sixteen integers, performing eight integer additions, in the time it would ordinarily take to operate on two integers, performing one integer addition.

HotSpot supports auto-vectorization where scalar operations are transformed into superword operations, which are then mapped to vector hardware instructions. The set of transformable scalar operations are limited and fragile to changes in the code shape. Furthermore, only a subset of available vector hardware instructions might be utilized limiting the performance of generated code.

A developer wishing to write scalar operations that are reliably transformed into superword operations needs to understand HotSpot's auto-vectorization support and its limitations to achieve reliable and sustainable performance.

In some cases it may not be possible for the developer to write scalar operations that are transformable. For example, HotSpot does not transform the simple scalar operations for calculating the hash code of an array (see the Arrays::hashCode method implementations in the JDK source code), nor can it auto-vectorize code to lexicographically compare two arrays (which is why an intrinsic was added to perform lexicographical comparison, see 8033148).

The Vector API aims to address these issues by providing a mechanism to write complex vector algorithms in Java, using pre-existing support in HotSpot for vectorization, but with a user model which makes vectorization far more predictable and robust. Hand-coded vector loops can express high-performance algorithms (such as vectorized hashCode or specialized array comparison) which an auto-vectorizer may never optimize. There are numerous domains where this explicitly vectorizing API may be applicable such as machine learning, linear algebra, cryptography, finance, and usages within the JDK itself.

[[java-17-feature-vector-description]]
=== 描述

A vector will be represented by the abstract class Vector<E>. The type variable E corresponds to the boxed type of scalar primitive integral or floating point element types covered by the vector. A vector also has a shape which defines the size, in bits, of the vector. The shape of the vector will govern how an instance of Vector<E> is mapped to a vector hardware register when vector computations are compiled by the HotSpot C2 compiler (see later for a mapping from instances to x64 vector registers). The length of a vector (number of lanes or elements) will be the vector size divided by the element size.

The set of element types (E) supported will be Byte, Short, Integer, Long, Float and Double corresponding to the scalar primitive types byte, short, int, long, float and double, respectively.

The set of shapes supported will correspond to vector sizes of 64, 128, 256, and 512 bits. A shape corresponding to a size of 512 bits can pack bytes into 64 lanes or pack ints into 16 lanes, and a vector of such a shape can operate on 64 bytes at a time, or 16 ints at a time.

NOTE:: We believe that these simple shapes are generic enough to be useful on all platforms supporting the Vector API. However, as we experiment during the incubation of this JEP with future platforms, we may further modify the design of the shape parameter. Such work is not in the early scope of this JEP, but these possibilities partly inform the present role of shapes in the Vector API. See the Future Work section, below.

The combination of element type and shape determines the vector's species, represented by VectorSpecies<E>

An instance of Vector<E> is immutable and is a value-based type that retains, by default, object identity invariants (see later for relaxation of these invariants).

Operations on vectors can be classified as lane-wise and cross-lane. Lane-wise operations can be further classified as unary, binary, ternary, and comparison. Cross-lane operations can be classified as permutation, conversion, and reduction. To reduce the surface of the API, we will define collective methods for each class of operation which then take an operator as input. The supported operators are instances of Operator class and are defined as static final fields in the VectorOperators class. Some common operations (e.g., add, mul), called full-service operations, will have dedicated methods which can be used in place of the generic methods.

Certain operations on vectors, such lane-wise cast and reinterpret, can be said to be inherently shape-changing. Having shape-changing operations in a vector computation could have unintended effects on portability and performance. For this reason, wherever applicable, the API will define an additional shape-invariant flavor of such an operation. Users are encouraged to write shape-invariant code using the shape-invariant flavor of operations. Additionally, shape-changing operations will be clearly called out in the Javadoc.

Vector<E> declares a set of methods for common vector operations supported by all element types. To support operations specific to an element type there are six abstract sub-classes of Vector<E>, one for each supported element type: ByteVector, ShortVector, IntVector, LongVector, FloatVector, and DoubleVector. These sub-classes define additional operations which are bound to the element type since the method signature refers to the element type (or the equivalent array type), such as reduction operations (e.g., sum all elements to a scalar value) or storing the vector elements to an array. They also define additional full-service operations that are specific to the integral sub-types such as bitwise operations (e.g., logical or), and operations specific to the floating point types, such as mathematical operations (e.g., transcendental functions such as pow()).

These classes are further extended by concrete sub-classes defined for different shapes (size) of Vectors.

The concrete sub-classes are non-public since there is no need to provide operations specific to the type and shape. This reduces the API surface to a sum of concerns rather than a product. As a result, instances of concrete Vector classes cannot be constructed directly. Instead, instances are obtained via factories methods defined in the base Vector<E> class and its type-specific sub-classes. These methods take as input the species of the desired vector instance. The factory methods provide different ways to obtain vector instances, such as the vector instance whose elements are initiated to default values (the zero vector), or a vector from an array, in addition to providing the canonical support for converting between vectors of different types or shapes (e.g., casting).

To support control flow, relevant vector operations will optionally accept masks represented by the public abstract class VectorMask<E>. Each element in a mask, a boolean value or bit, corresponds to a vector lane. When a mask is an input to an operation it governs whether the operation is applied to each lane; the operation is applied if the mask bit for the lane is set (is true). Alternative behavior occurs if the mask bit is not set (is false). Similar to vectors, instances of VectorMask<E> are instances of (private) concrete sub-class defined for each element type and length combination. The instance of VectorMask<E> used in an operation should have the same type and length as the instance(s) of Vector<E> involved in the operation. Comparison operations produce masks, which can then be input to other operations to selectively disable the operation on certain lanes and thereby emulate flow control. Another way for creating masks is using static factory methods in VectorMask<E>.

We anticipate that masks will likely play an important role in the development of vector computations that are generic to shape. (This expectation is based on the central importance of predicate registers, the equivalent of masks, in the ARM Scalable Vector Extensions as well as in Intel's AVX-512.)

[[java-17-feature-vector-example]]
=== example

下面是对数组元素的常规简单计算:

[source,java]
----
void scalarComputation(float[] a, float[] b, float[] c) {
   for (int i = 0; i < a.length; i++) {
        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
   }
}
----

我们假设数组参数的大小相同

使用 Vector API 实现等效向量计算的方法如下：

[source,java]
----
static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;

void vectorComputation(float[] a, float[] b, float[] c) {

    for (int i = 0; i < a.length; i += SPECIES.length()) {
        var m = SPECIES.indexInRange(i, a.length);
		// FloatVector va, vb, vc;
        var va = FloatVector.fromArray(SPECIES, a, i, m);
        var vb = FloatVector.fromArray(SPECIES, b, i, m);
        var vc = va.mul(va).
                    add(vb.mul(vb)).
                    neg();
        vc.intoArray(c, i, m);
    }
}
----

在这个例子中，从 FloatVector 获得了一个 256 位的浮点向量 SPECIES。SPECIES 存储在一个静态 final 字段中，因此运行时编译器将该字段的值视为常量，从而能够更好地优化向量计算。

向量计算的特点是主循环内以向量长度(即 SPECIES 长度)的步长遍历数组。静态方法 `fromArray()` 从数组 a 和 b 的对应索引处加载给定 SPECIES 的浮点向量。然后执行操作，最后将结果存储到数组 c 中。

我们使用由 `indexInRange()` 生成的 mask 来防止读取/写入超过数组长度。第一层( a.length / SPECIES.length() )迭代将设置一个所有通道的 mask。只有最后一次迭代，如果 a.length 不是 SPECIES.length() 的倍数，才会有一个设置了 a.length % SPECIES.length() 的 mask。

由于 mask 在所有迭代中都使用，因此上述实现对于大数组长度可能无法实现最佳性能。同样的计算可以在没有 mask 的情况下实现如下:

[source,java]
----
// Example 2

static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;

void vectorComputation(float[] a, float[] b, float[] c) {
    int i = 0;
    int upperBound = SPECIES.loopBound(a.length);
    for (; i < upperBound; i += SPECIES.length()) {
        // FloatVector va, vb, vc;
        var va = FloatVector.fromArray(SPECIES, a, i);
        var vb = FloatVector.fromArray(SPECIES, b, i);
        var vc = va.mul(va).
                    add(vb.mul(vb)).
                    neg();
        vc.intoArray(c, i);
    }

    for (; i < a.length; i++) {
        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
    }
}
----

对于长度小于 species  长度的尾部元素，在进行向量计算后，再进行常规计算。处理尾部元素的另一种方法是使用单一的 masked 向量计算。

当操作大型数组时，上述实现可以获得最佳性能。

对于第二个例子，HotSpot 编译器应该在支持 AVX 的 Intel x64 处理器上生成类似如下的机器码:

[source,txt]
----
0.43%  / │  0x0000000113d43890: vmovdqu 0x10(%r8,%rbx,4),%ymm0
  7.38%  │ │  0x0000000113d43897: vmovdqu 0x10(%r10,%rbx,4),%ymm1
  8.70%  │ │  0x0000000113d4389e: vmulps %ymm0,%ymm0,%ymm0
  5.60%  │ │  0x0000000113d438a2: vmulps %ymm1,%ymm1,%ymm1
 13.16%  │ │  0x0000000113d438a6: vaddps %ymm0,%ymm1,%ymm0
 21.86%  │ │  0x0000000113d438aa: vxorps -0x7ad76b2(%rip),%ymm0,%ymm0
  7.66%  │ │  0x0000000113d438b2: vmovdqu %ymm0,0x10(%r9,%rbx,4)
 26.20%  │ │  0x0000000113d438b9: add    $0x8,%ebx
  6.44%  │ │  0x0000000113d438bc: cmp    %r11d,%ebx
         \ │  0x0000000113d438bf: jl     0x0000000113d43890
----

This is actual output from a JMH micro-benchmark for the example code under test using a prototype of the Vector API and implementation (the vectorIntrinsics branch of Project Panama's development repository). This shows the hot areas of C2-generated machine code. There is a clear translation to vector registers and vector hardware instructions. (Loop unrolling was disabled to make the translation clearer, otherwise HotSpot should be able to unroll using existing C2 loop optimization techniques.) All Java object allocations are elided.

It is an important goal to support more complex non-trivial vector computations that translate clearly into generated machine code.

There are, however, a few issues with this particular vector computation:

. The loop is hardcoded to a concrete vector shape, so the computation cannot adapt dynamically to a maximal shape supported by the architecture, which may be smaller or larger than 256 bits. Therefore the code is less portable and may be less performant.
. Calculation of the loop upper bounds, although simple here, can be a common source of programming error.
. A scalar loop is required at the end, duplicating code.

We will address the first two issues in this JEP. A preferred species can be obtained whose shape is optimal for the current architecture, the vector computation can then be written with a generic shape, and a method on the species can round down the array length, for example:

[source,java]
----
static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;

void vectorComputation(float[] a, float[] b, float[] c,
        VectorSpecies<Float> species) {
    int i = 0;
    int upperBound = species.loopBound(a.length);
    for (; i < upperBound; i += species.length()) {
        //FloatVector va, vb, vc;
        var va = FloatVector.fromArray(species, a, i);
        var vb = FloatVector.fromArray(species, b, i);
        var vc = va.mul(va).
                    add(vb.mul(vb)).
                    neg();
        vc.intoArray(c, i);
    }

    for (; i < a.length; i++) {
        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
    }
}

vectorComputation(a, b, c, SPECIES);
----

The third issue will not be fully addressed by this JEP and will be the subject of future work. As shown in the first example, you can use masks to implement vector computation without tail processing. We anticipate that such masked loops will work well for a range of architectures, including x64 and ARM, but will require additional runtime compiler support to generate maximally efficient code. Such work on masked loops, though important, is beyond the scope of this JEP.

[[java-17-feature-vector-hotspot]]
=== HotSpot C2 编译器细节

The Vector API has two implementations in order to achieve this JEP's goals. The first implements operations in Java, thus it is functional but not optimal. The second makes intrinsic, for the HotSpot C2 compiler, those operations with special treatment for Vector API types. This allows for proper translation to hardware registers and instructions for the case where architecture support and implementation for translation exists.

To avoid an explosion of intrinsics added to C2, a set of intrinsics will be defined that correspond to operation kinds such as binary, unary, comparison, and so on, where constant arguments are passed describing operation specifics. Approximately twenty new intrinsics will be needed to support the intrinsification of all parts of the API.

Vector instances are value-based, i.e., morally values where identity-sensitive operations should be avoided. Further, although vector instances are abstractly composed of elements in lanes, those elements are not scalarized by C2. The vector value is treated as a whole unit, like int or long, that maps to a hardware vector register of the appropriate size. Inline types will require some related enhancements to ensure that a vector value is treat as a whole unit.

Until inline types are available, Vector instances will be treated specially by C2 to overcome limitations in escape analysis and avoid boxing. As such, identity sensitive operations on vectors should be avoided.

[[java-17-feature-vector-future]]
=== 未来工作

The Vector API will benefit significantly from value types once ready (see Project Valhalla). Instances of a Vector<E> can be values, whose concrete classes are inline types. This will make it easier to optimize and express vector computations. Sub-types of Vector<E> for specific types, such as IntVector, may not be required with generic specialization over inline types and type-specific method declaration.

Therefore, a future version of the Vector API will make use of inline types and enhanced generics, as noted above. As a result, we will incubate the API over multiple releases of the JDK and will adapt as inlines types become available.

We will enhance the API to load and store vectors using features of JEP 370 Foreign-Memory Access API, when that API transitions from an incubating API. Further, memory layouts to describe vector species may prove useful, for example to stride over a memory segment comprised of elements.

We anticipate enhancing the implementation in the following ways:

* Include support for vectorized transcendental operations (such as logarithm, and the trigonometric functions),
* Improve the optimization of loops containing vectorized code,
* Optimize masked vector operations on supporting platforms, and
* Make adjustments for large vector sizes (e.g., as supported by ARM SVE).

Performance work will be ongoing as we make incremental improvements to the implementation.

[[java-17-feature-vector-alternatives]]
=== 备选方案

HotSpot's auto-vectorization is an alternative approach, but it would require significant work. It would, moreover, likely still be fragile and limited compared to using the Vector API, since auto-vectorization with complex control flow is very hard to perform.

In general, and even after decades of research (especially for FORTRAN and C array loops), it seems that auto-vectorization of scalar code is not a reliable tactic for optimizing ad-hoc user-written loops unless the user pays unusually careful attention to unwritten contracts about exactly which loops a compiler is prepared to auto-vectorize. It's too easy to write a loop that fails to auto-vectorize, for a reason that the optimizer but no human reader can detect. Years of work on auto-vectorization, even in HotSpot, have left us with lots of optimization machinery that works only on special occasions. We want to enjoy the use of this machinery more often!

[[java-17-feature-vector-testing]]
=== 测试

We will develop combinatorial unit tests to ensure coverage for all operations, for all supported types and shapes, over various data sets.

We will also develop performance tests to ensure that performance goals are met and vector computations map efficiently to vector hardware instructions. This will likely consist of JMH micro-benchmarks, but more realistic examples of useful algorithms will also be required. Such tests may initially reside in a project specific repository. Curation is likely required before integration into the main repository given the proportion of tests and how they are generated.

As a backup to performance tests, we may create white-box tests to force the JIT to report to us that vector API source code did, in fact, trigger vectorization.

[[java-17-feature-vector-risks]]
=== 风险和假设

There is a risk that the API will be biased to the SIMD functionality supported on x64 architectures but this is mitigated with support for AArch64. This applies mainly to the explicitly fixed set of supported shapes, which bias against coding algorithms in a shape-generic fashion. We consider the majority of other operations of the Vector API to bias toward portable algorithms. To mitigate that risk we will take other architectures into account, specifically the ARM Scalar Vector Extension architecture whose programming model adjusts dynamically to the singular fixed shape supported by the hardware. We welcome and encourage OpenJDK contributors working on the ARM-specific areas of HotSpot to participate in this effort.

The Vector API uses box types (such as Integer) as proxies for primitive types (such as int). This decision is forced by the current limitations of Java generics, which are hostile to primitive types. When Project Vahalla eventually introduces more capable generics the current decision will seem awkward, and may need changing. We assume that such changes will be possible without excessive backward incompatibility.

[[java-17-feature-deserialization]]
== 特定于上下文的反序列化过滤器

允许应用程序使用 JVM 范围的过滤器工厂配置特定于上下文和动态选择的反序列化过滤器，该工厂用于为每个反序列化操作选择一个过滤器。

动机：

不可信数据的反序列化是一项具有内在风险的操作，因为在许多情况下传入数据流的内容是通过未知或未经身份验证的客户端获取的。

防止序列化攻击的关键是禁止任意类的实例被反序列化，从而直接或间接地阻止其方法的执行。

攻击者可以通过仔细构造流来运行任何恶意的类中的代码。如果对象构造涉及更改状态或触发其他操作的副作用，则应用程序对象、库对象和 Java 运行时的完整性可能会受到损害。
