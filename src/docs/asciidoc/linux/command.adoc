[[linux-command]]
= Linux 常用命令

[[linux-command-tip]]
== Linux 命令提示符

[source,shell]
----
[root@localhost ~]#
----

* `[]`:这是提示符的分割符号，没有特殊含义
* root:显示的是当前登录用户
* @: 分割符号，没有特殊含义
* localhost:当前系统的简写主机名
* ~:代表当前用户所在的目录
* `\#` : 命令提示符，`#` 是超级用户 `$` 是普通用户

[[linux-command-format]]
== Linux 命令基本格式

[source,shell]
----
[root@localhost ~]# 命令 [选项] [参数]
----

[[linux-command-directory]]
== 目录操作

[[linux-command-directory-ls]]
=== `ls` 命令

==== ls 命令基本信息

`ls` 是常见的目录操作命令，主要作用是显示目录下的内容

* 命令名称: ls
* 英文原意: list
* 所在路径: /bin/ls
* 执行权限: 所有用户
* 功能描述: 显示目录下的内容

[source,shell]
----
[root@localhost ~]# ls [选项] [文件名或目录名]
----

==== ls 命名选项

. `ls` 命名选项
|===
|选项 |描述

|-a
|显示所有文件

|--color=when
|支持颜色输出，when 的默认值是 `always` (总是显示)，也可以使 `never` (从不显示) 和 `auto` (自动)

|-d
|显示目录信息，而不是目录下的文件

|-h
|人性化显示，按照我的习惯的单位显示文件大小

|-i
|显示文件的 i 节点号

|-l
|长格式显示
|===

例如:使用 `ls -l` 内容如下

[source,shell]
----
[root@localhost ~]# ls -l
总用量 4
-rw-------. 1       root     root  1343 10月 22 14:48 anaconda-ks.cfg
# 权限       引用计数 所有者     所属组 大小  文件修改时间    文件名
----

. `-l` 参数列说明
|===
|列 |描述

| 1
| 权限，具体权限在 <<linux-command-permission>> 中说明

| 2
| 引用计数。文件的引用计数代表文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。

| 3
| 所有者，也就是这个文件属于哪个用户。默认所有者就是文件的创建者

| 4
| 所属组。默认所属组就是文件建立用户的有效组，一般情况下就是建立用户的所属组。

| 5
| 大小，默认是字节

| 6
| 文件修改时间，文件状态修改时间或者文件数据修改时间都会更改这个时间，注意这个时间不是文件创建的时间

| 7
| 文件名
|===

[[linux-command-directory-cd]]
=== `cd` 命令

`cd` 是切换所在目录的命令

* 命令名称: cd
* 英文原意: change directory
* 所在路径: Shell 内置命令
* 执行权限: 所有用户
* 功能描述: 切换所在目录

==== cd 命令的简化使用

|===
|特殊符号 |作用

| `~`
|代表用户的家目录

| `-`
|代表上次所在的目录

| `.`
|代表当前目录

| `..`
|代表上级目录
|===

[[linux-command-directory-pwd]]
=== `pwd` 命令

`pwd` 是是查询所在目录命令

* 命令名称: pwd
* 英文原意: print name of current/working directory
* 所在路径: /bin/pwd
* 执行权限: 所有用户
* 功能描述: 查询所在的工作目录

[[linux-command-directory-mkdir]]
=== `mkdir` 命令

`mkdir` 是是创建目录命令

* 命令名称: mkdir
* 英文原意: make directories
* 所在路径: /bin/mkdir
* 执行权限: 所有用户
* 功能描述: 创建空目录

`-p` 参数可以递归创建目录

[[linux-command-directory-rmdir]]
=== `rmdir` 命令

`rmdir` 是是删除目录命令

* 命令名称: rmdir
* 英文原意: remove empty directories
* 所在路径: /bin/rmdir
* 执行权限: 所有用户
* 功能描述: 删除空目录

`-p` : 递归删除目录

[NOTE]
====
rmdir 命令作用十分有限，因为只能删除空目录。所有一旦目录中有内容，就会报错。可以参考 <<linux-command-file-directory-rm>> 命令。
====

[[linux-command-file]]
== 文件操作

[[linux-command-file-touch]]
=== `touch` 命令

`touch` 创建空文件或修改文件时间

* 命令名称: touch
* 英文原意: change file timestamps
* 所在路径: /bin/touch
* 执行权限: 所有用户
* 功能描述: 修改文件的时间戳

[[linux-command-file-stat]]
=== `stat` 命令

`stat` 查看文件详细信息

* 命令名称: stat
* 英文原意: display file or file system status
* 所在路径: /usr/bin/stat
* 执行权限: 所有用户
* 功能描述: 显示文件或者文件系统的详细信息

[source,shell]
----
[root@localhost ~]# stat anaconda-ks.cfg
  文件:"anaconda-ks.cfg"
  大小:1343      	块:8          IO 块:4096   普通文件
设备:fd00h/64768d	Inode:100663394   硬链接:1
权限:(0600/-rw-------)  Uid:(    0/    root)   Gid:(    0/    root)
环境:system_u:object_r:admin_home_t:s0
最近访问:2020-10-28 17:09:35.345425586 +0800
最近更改:2020-10-22 14:48:38.846449902 +0800 # 数据修改时间
最近改动:2020-10-22 14:48:38.846449902 +0800 # 状态修改时间
创建时间:-
----

[[linux-command-file-cat]]
=== `cat` 命令

`cat` 合并文件并打印输出到标准输出

* 命令名称: cat
* 英文原意: display file or file system status
* 所在路径: /bin/cat
* 执行权限: 所有用户
* 功能描述: 显示文件或者文件系统的详细信息

.`cat` 选项
|===
|参数 |说明

| -A
| 相当于 `-vET` 选项的整合，用于列出所有隐藏符号

| -E
| 列出每行结尾的回车符 `$`

| -n
| 显示行号

| -T
| 把 Tab 键用 `^I` 显示出来

| -v
| 列出特殊字符
|===

[[linux-command-file-more]]
=== `more` 命令

`more` 分屏显示文件内容

* 命令名称: more
* 英文原意: file perusal filter for crt viewin
* 所在路径: /bin/more
* 执行权限: 所有用户
* 功能描述: 分屏显示文件内容

`more` 命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令:

* 空格键:向下翻页
* b: 向上翻页
* 回车键: 向下滚动一行
* /字符串:搜索指定的字符串
* q: 退出

[[linux-command-file-less]]
=== `less` 命令

`less` 和 `more` 命令非常相似，只是 more 是分屏显示命令，`less` 是分行显示命令。

* 命令名称: less
* 英文原意: opposite of more
* 所在路径: /usr/bin/less
* 执行权限: 所有用户
* 功能描述: 分行显示文件内容

[[linux-command-file-head]]
=== `head` 命令

`head` 显示文件开头。

* 命令名称: head
* 英文原意: output the first part of files
* 所在路径: /usr/bin/head
* 执行权限: 所有用户
* 功能描述: 显示文件开头的内容

.`head` 选项
|===
|参数 |说明

| -n 行数
| 从文件头开始，显示指定行数

| -v
| 显示文件名
|===

[[linux-command-file-tail]]
=== `tail` 命令

`tail` 显示文件结尾的命令。

* 命令名称: tail
* 英文原意: output the last part of files
* 所在路径: /usr/bin/tail
* 执行权限: 所有用户
* 功能描述: 显示文件结尾的内容

.`tail` 选项
|===
|参数 |说明

| -n 行数
| 从文件结尾开始，显示指定行数

| -f
| 监听文件的新增内容
|===

[[linux-command-file-ln]]
=== `ln` 命令

`ln` 在文件之间建立链接。

* 命令名称: ln
* 英文原意: make links between file
* 所在路径: /bin/ln
* 执行权限: 所有用户
* 功能描述: 在文件之间建立链接

[source,shell]
----
[root@localhost ~]# ln [选项] 源文件 目标文件
----

.`ln` 选项
|===
|参数 |说明

| -s
| 建立软链接文件。如果不加 `-s` 选项，默认建立硬链接

| -f
| 强制。如果目标文件已存在。则删除目标文件后再建立链接
|===

.软连接和硬链接的特征
****
硬链接特征:

* 源文件和硬链接文件拥有相同的 Inode 和 Block
* 修改任意一个文件，另一个都改变
* 删除任意一个文件，另一个都能用
* 硬链接标记不清，很难确认硬链接文件位置。不建议使用
* 硬链接不能链接目录
* 硬链接不能跨分区

软链接特征

* 源文件和软链接文件拥有不同的 Inode 和 Block
* 修改任意一个文件，另一个都改变
* 删除软链接，源文件不受影响。删除源文件，软链接不能使用
* 软链接没有实际数据，只能保存源文件的 Inode，不论源文件多大，软链接大小不变
* 软链接的权限是最大权限 `lrwxrwxrwx`,但是由于没有实际数据，最终访问时需要参考源文件权限
* 软链接可以链接目录
* 软链接可以跨分区
* 软链接特征明显，建议使用软链接
****

[[linux-command-file-directory]]
== 目录和文件

[[linux-command-file-directory-rm]]
=== `rm` 命令

`rm` 是强大的删除命令，不仅可以删除文件，也可以删除目录。

* 命令名称: rm
* 英文原意: remove files or directories
* 所在路径: /bin/rm
* 执行权限: 所有用户
* 功能描述: 删除文件或目录

.`rm` 选项
|===
|参数 |说明

| -f
| 强制删除

| -i
| 交互删除，在删除之前会询问用户

| -r
| 递归删除，可以删除目录
|===

[[linux-command-file-directory-cp]]
=== `cp` 命令

`cp` 是复制命令。

* 命令名称: cp
* 英文原意: copy files or directories
* 所在路径: /bin/cp
* 执行权限: 所有用户
* 功能描述: 复制文件或目录

.`cp` 选项
|===
|参数 |说明

| -a
| 相当于 `-dpr` 的集合

| -d
| 如果源文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接

| -i
| 询问，如果目标文件已经存在，会询问用户是否覆盖

| -p
| 复制后目标文件保留源文件的属性(包括所有者，所属组，权限和时间)。

| -r
| 递归复制，复制目录
|===

[[linux-command-file-directory-mv]]
=== `mv` 命令

`mv` 是剪贴命令。

* 命令名称: mv
* 英文原意: move(rename) files
* 所在路径: /bin/mv
* 执行权限: 所有用户
* 功能描述: 移动文件或改名

.`mv` 选项
|===
|参数 |说明

| -f
| 强制覆盖。如果目标文件已经存在，不再询问，直接覆盖。

| -i
| 交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认选项)

| -v
| 显示详细信息
|===

[[linux-command-permission]]
== 基本权限管理

首先我们看下面这个示例:

[source,shell]
----
[root@localhost ~]# ls -l
总用量 4
-rw-------. 1 root root 1343 10月 22 14:48 anaconda-ks.cfg
----

首先第一列就代表了权限位，如果不计算最后的 `.` (`.` 在 <<perrmission.adoc#permission>> 中说明)。 则共有 `10` 位.这 10 位的含义为下

image::{oss-images}/linux1.png[]

* 第一位代表文件类型:Linux 中不像 Windows 那样使用扩展名表示文件类型。而是使用权限位的第一位表示文件类型。详细情况可以使用 `info ls` 命令查看，下面是一些常见的文件类型。
+
|===
|标识符 |文件类型

| -
| 普通文件

| b
| 块设备文件，是一种特殊的设备文件，存储设备都是这种文件。如分区文件 /dev/sda1 就是这种文件

| c
| 字符设备文件，也是特殊文件，输入设备一般都是这种文件。如鼠标，键盘等。

| d
| 目录文件。Linux 中一切皆文件，所以目录也是文件的一种

| l
| 软链接文件

| p
| 管道符文件，这是一种非常少见的特殊设备文件

| s
| 套接字文件。这也是一种特殊设备文件，一些服务支撑 socket 访问，就会产生这样的文件
|===

* 2-4 位表示文件所有者权限
** -: 无权限
** r: 代表 read，是读取权限
** w: 代表 write，是写权限
** x: 代表 execute，代表执行权限
* 5-7 代表文件所属组的权限。同样拥有 `rwx` 权限
* 8-10 代表其他人权限，同样拥有 `rwx` 权限

[[linux-command-permission-chmod]]
=== 基本权限命令 (`chmod`)

`chmod` 是修改权限命令

* 命令名称: chmod
* 英文原意: change file mode bits
* 所在路径: /bin/chmod
* 执行权限: 所有用户
* 功能描述: 修改文件的权限模式

[source,shell]
. 命令格式
----
[root@localhost ~]# chmod [选项] 权限模式 文件名
----

-R : 递归设置模式

==== 权限模式

chmod 命令的权限模式的格式是 `[ugoa][[+-=][perms]]` 也就是  `[用户身份][[赋予方式][权限]]`

用户身份:

* u : 代表所有者(user)
* g : 代表所属组(group)
* o : 代表其他人(other)
* a : 代表全部身份(all)

赋予方式:

* + : 赋予权限
* - : 减去权限
* = : 设置权限

权限:

* r : 读取权限(read)
* w : 写权限(write)
* x : 执行权限(execute)

==== 数字权限

数字权限的赋予方式是最简单的，但不如字母的方式好记。

* 4 : 代表 `r` 权限
* 2 : 代表 `w` 权限
* 1 : 代表 `x` 权限

==== 常用权限

* 644 : 这是文件的基本权限。代表所有者拥有读写操作，而所属组和其他人只有读权限
* 755 : 这是文件的执行权限和目录的基本权限。代表所有者拥有读写和执行权限，而所属组和其他人拥有读和执行权限
* 777 : 这是最大权限

[[linux-command-permission-base]]
=== 基本权限作用

==== 权限含义解释

首先，读，写，执行权限对文件和目录的作用是不一样的。

权限对文件的作用

* 读(r) : 对文件有 读(r) 权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件拥有 读(r) 权限，就可以对文件执行 `cat`,`more`,`less`,`head`,`tail` 等文件查看命令
* 写(w) : 对文件有 写(w) 权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件拥有 写(w) 权限，就可以对文件执行 `vim`,`echo` 等修改文件的命令。**注意，对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要删除文件，则需要对文件的上级目录拥有写权限**
* 执行(x) : 对文件有 执行(x) 权限，代表文件拥有了执行权限。那么一旦对文件拥有 执行(x) 权限，这个文件就是执行文件了，至于到底能不能正确执行，还得看文件中的代码语法是不是正确。对文件来说，执行(x) 权限是最高权限。

权限对目录的作用

* 读(r) : 对目录有 读(r) 权限，代表可以查看目录下的内容。如果把权限对应到命令上，那么一旦对目录拥有 读(r) 权限，就可以对目录执行 `ls` 等命令
* 写(w) : 对目录有 写(w) 权限，代表可以修改目录下的内容。如果把权限对应到命令上，那么一旦对目录拥有 写(w) 权限，就可以对目录执行 `touch`,`mv`,`rm`,`cp` 等命令。**对目录来说，写(w)  权限是最高权限。**
* 执行(x) : 目录是不能运行的，那么对目录拥有 执行(x) 权限，代表可以进入目录。如果把权限对应到命令上，就可以对目录执行 `cd` 命令,进入目录。


目录的可用权限:

* 0 : 任何权限都不赋予
* 5 : 基本的目录浏览和进入权限
* 7 : 完全权限

[[linux-command-permission-chown]]
=== `chown` 命令

`chown` 是修改文件和目录的所有者和所属组命令

* 命令名称: chown
* 英文原意: change file owner and group
* 所在路径: /bin/chown
* 执行权限: 所有用户
* 功能描述: 修改文件和目录的所有者和所属组

[source,shell]
----
[root@localhost ~]# chown [选项] 所有者:所属组 文件或目录
----

-R : 递归设置权限

[[linux-command-permission-chgrp]]
=== `chgrp` 命令

`chgrp` 是修改文件和目录的所有组命令

* 命令名称: chgrp
* 英文原意: change group ownership
* 所在路径: /bin/chgrp
* 执行权限: 所有用户
* 功能描述: 修改文件和目录的所有组

[[linux-command-permission-umask]]
=== `umask` 命令

`umask` 是修改文件与目录的默认权限命令

* 命令名称: umask
* 英文原意: change group ownership
* 所在路径: /bin/umask
* 执行权限: 所有用户
* 功能描述: 文件与目录的默认权限

[source,shell]
----
[root@localhost bin]# umask
0022
# 用八进制数值显示 umask 权限
[root@localhost bin]# umask -S
u=rwx,g=rx,o=rx
# 用字母表示文件和目录的初始权限
----

==== umask 权限的计算方法

我们需要了解一下新建文件或目录的默认最大权限

* 对文件来讲，新建文件的默认最大权限是 `666` ，没有执行权限。这是因为执行权限对文件来讲比较危险，不能在新建权限的时候默认赋予。而必须手工赋予
* 对目录来讲，新建目录的默认最大权限是 `777` ，这是因为对目录而言，执行权限仅仅代表可以进入目录。所以即使建立新文件是直接默认赋予，也没有什么危险。

按照官方标准的算法，umask 默认权限需要使用二进制逻辑与和逻辑非联合运算才能得到正确的新建文件和目录的默认权限。这种方法即不好算，也不好立即。可以使用下面的方法

按照权限字母来计算。我们就按照默认的 `umask` 值是 022 来说

* 文件的默认最大权限为 `666`，而 umask 的值为 `022`，新建文件时:(-rw-rw-rw-) - (-----w--w-) ==> -rw-r--r--
* 目录的默认最大权限为 `777`，而 umask 的值为 `022`，新建目录时:(drwxrwxrwx) - (d----w--w-) ==> drwxr-xr-x

[[linux-command-help]]
== 帮助命令

[[linux-command-help-man]]
=== `man` 是最常见的帮助文档命令

`man` 是常见的目录操作命令

* 命令名称: man
* 英文原意: format and display the on-line manual pages
* 所在路径: /usr/bin/man
* 执行权限: 所有用户
* 功能描述: 显示联机帮助手册

. man 命令选项
|===
|参数 |说明

| -f
| 查看命令拥有那个级别的帮助

| -k
| 查看和命令相关的所有帮助
|===

. man 命令快捷键
|===
|快捷键 |作用

|上箭头
|向上移动一行

|下箭头
|向下移动一行

|PgDn
|向上翻页

|PgDown
|向下翻页

|g
|移动到第一页

|G
|移动到最后一页

|q
|退出

| /字符串
| 从当前页向下搜索字符串

| ?字符串
| 从当前一向上搜索字符串

| n
| 当搜素字符串时，可以使用 n 键找到下一个字符串

| N
|当搜素字符串时，可以使用 N 键反向查询字符串
|===


.`man` 命令的帮助级别
|===
|级别 |作用

| 1
| 普通用户可以执行的系统命令和可执行文件的帮助

| 2
| 内核可以调研的函数和工具的帮助

| 3
| C 语言函数的帮助

| 4
| 设备和特殊文件的帮助

| 5
| 配置文件的帮助

| 6
| 游戏的帮助

| 7
| 杂项的帮助

| 8
| 超级用户可以执行的系统命令的帮助

| 9
| 内核的帮助
|===

[[linux-command-help-info]]
=== `info` 命令

`info` 命令的帮助文档是一套完整的资料，每个单独命令的帮助文档只是这套完整资料的某一章小节

. info 命令快捷键
|===
|快捷键 |作用

|上箭头
|向上移动一行

|下箭头
|向下移动一行

|PgDn
|向上翻页

|PgDown
|向下翻页

|Tab
| 在带有 `*` 符合的节点间切换

|回车
|进入有 `*` 符号的子页面，查看详细的帮助文档

|u
|进入上一层信息(回车是进入下一层)

|n
|进入下一小节信息

|p
|进入上一小节信息

| ?
| 查看帮助信息

|q
|退出
|===

[[linux-command-help-help]]
=== `help` 命令

`help` 只能获取 shell 内置命令的帮助

* 命令名称: help
* 英文原意: help
* 所在路径: /bin/help
* 执行权限: 所有用户
* 功能描述: 获取 shell 内置命令的帮助

[[linux-command-help-help2]]
=== `--help` 选项

绝大多数命令都能使用 `--help` 选项获取帮助。

[[linux-command-search]]
== 搜索命令

[[linux-command-search-whereis]]
=== `whereis` 命令

`whereis` 是搜索系统命令的命令。也就是说 whereis 命令不能搜索普通文件。

* 命令名称: whereis
* 英文原意: locate the binary,source,and manual page files for a command
* 所在路径: /usr/bin/whereis
* 执行权限: 所有用户
* 功能描述: 查找二进制命令，源文件和帮助文档的命令

[source,shell]
----
whereis ls
# 查找文件(需要更新库:updatedb)
----

[[linux-command-search-which]]
=== `which` 命令

`which` 是搜索系统命令的命令。

* 命令名称: which
* 英文原意: show a full path of(shell) commands
* 所在路径: /usr/bin/which
* 执行权限: 所有用户
* 功能描述: 列出命令的所在路径

.which 和 whereis 的区别
****
whereis 命令可以在查找到二进制命令的同时，查找到帮助文档的位置

而 which 命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。
****

[source,shell]
----
which ls
# 查找可执行的命令和帮助的位置:
----

[[linux-command-search-locate]]
=== `locate` 命令

`locate` 按照文件名进行搜索的命令

* 命令名称: locate
* 英文原意: list
* 所在路径: /usr/bin/locate
* 执行权限: 所有用户
* 功能描述: 按照文件名搜索文件

`locate` 按照数据库进行搜索，搜索速度快。数据库位于 `/var/lib/mlocate/mlocate.db`. 可以使用 `updatedb` 命令强制更新数据库。

只能按照文件名进行搜索，不能按照大小，权限，时间等搜索文件。

[NOTE]
====
centos7 默认是没有安装 `mlocate` 的，所以无法使用 `locate` 和 `updatedb` 这两个命令
====

配置文件:

[source,shell]
----
[root@localhost ~]# vi /etc/updatedb.conf
PRUNE_BIND_MOUNTS = "yes"
# 开启搜索限制，也就是让这个配置文件生效
PRUNEFS = "9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configfs cpuset debugfs devpts ecryptfs exofs fuse fuse.sshfs fusectl gfs gfs2 gpfs hugetlbfs inotifyfs iso9660 jffs2 lustre mqueue ncpfs nfs nfs4 nfsd pipefs proc ramfs rootfs rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs fuse.glusterfs ceph fuse.ceph"
# 在 locate 执行搜索时，禁止搜索这些文件系统类型
PRUNENAMES = ".git .hg .svn"
# 在 locate 执行搜索时，禁止搜索带有这些扩展名的文件
PRUNEPATHS = "/afs /media /mnt /net /sfs /tmp /udev /var/cache/ccache /var/lib/yum/yumdb /var/spool/cups /var/spool/squid /var/tmp /var/lib/ceph"
# 在 locate 执行搜索时，禁止搜索这些系统目录
----

[source,shell]
----
locate hello.txt
----

[[linux-command-search-find]]
=== `find` 命令

`find` 在目录中搜索文件

* 命令名称: find
* 英文原意: search for files in a directory hierarchy
* 所在路径: /bin/find
* 执行权限: 所有用户
* 功能描述: 在目录中搜索文件

[source,shell]
----
[root@localhost ~]# find 搜索路径 [选项] 搜索内容
----

.`find` 选项
|===
|参数 |说明 | 举例

| -name filename
| 按照文件名搜索
| find / -name passwd

| -iname
| 按照文件名搜索，不区分大小写
| find / -iname passwd

| -inum
| 按照 inode 号搜索
| find / -inum 2

| -size [+-]SIZE
| 安装指定大小搜索文件。`+` 代表搜索比指定的大小还要大的文件。`-` 代表搜索比指定大小还要小的文件。这个 `SIZE` 的规格有: `b`(这是默认单位，如果单位为 b 或者不写单位，则按照 512 Byte 搜索), `w`(按照双字节(中文)搜索), `c`(代表 byte),`k`(安装 kb 单位搜索，k 必须是小写),`M`(安装 MB 单位搜索，M 必须是大写),`G`(安装 GB 单位搜索，G 必须是大写)。
| find / -size +50k

| -atime [+-] n
| 按照文件访问时间搜索。`n` 为数字。`+n`  表示在 `n` 天之前(不含 n 天本身)的被更改过的文件名。`-n` 列出在 `n` 天之内(含 n 天本身) 被更改过的文件名。`n` 在 n 天之前的 "一天之内" 被更改过的文件。
| find / -atime 0

| -mtime  [+-] n
| 按照文件数据修改时间搜索
| find / -mtime 0

| -ctime  [+-] n
| 按照文件状态修改时间搜索
| find / -ctime 0

| -never file
| `file` 是一个已经存在的文件，列出比 `file` 还要新的文件名
| find /etc -never /etc/passwd

| -perm mode
| 查找文件权限刚好等于 "权限模式" 的文件
| find / -perm +7000

| -perm +mode
| 查找文件权限全部包含 "权限模式" 的文件
| find / -perm +7000

| -perm -mode
| 查找文件权限包含 "权限模式" 的任意一个权限的文件
| find / -perm +7000

| -uid 用户id
| 按照用户 id 查找所有者是指定 id 的文件
| find / -uid 10000

| -gid 组id
| 按照用户组 id 查找所属组是指定 id 的文件
| find / -gid 10000

| -user 用户名
| 按照用户名查找所有者是指定用户的文件
| find /usr -user hadoop -ls

| -group 组名
| 按照组名查找所属组是指定用户组的文件
| find /usr -group hadoop

| -nouser
| 查找没有所有者的文件
| find / -nouser

| -nogroup
| 查找没有所属组的文件
| find / -nogroup

| -type TYPE
| 查找文件类型为 `TYPE` 的文件。`TYPE` 类型主要有: `d`(目录),`f`(普通文件),`l`(软链接文件),`b,c`(设备文件),`s`(socket),`p`(FIFO).
| find /var -type s

| -a
| and 逻辑与
| find . -size +2k -a -type f

| -o
| or 逻辑或
| find . -name hello -o -name world

| -not
| not 逻辑非
| find . -not -name hello
|===

其他选项

[source,shell]
----
[root@localhost ~]# find 搜索路径 [选项] 搜索内容 -exec 命令2 {} \
----

`-exec` 这个选项的作用其实就是把 find 命令的结果交给由 `-exec` 调用的命令来处理。 `{}` 就代表 find 命令查找的结果.如下

[source,shell]
----
find / -name "hadooop*" -exec rm {} \;
----

`-ok` 选项和 `-exec` 选项的作用基本一致。区别在于，`-exec` 的命令2会直接处理。而不询问，`-ok` 的命令2 在处理前会先询问用户是否这样处理。在得到确认命令后，才会执行。

[source,shell]
----
find / -name "hadooop*" -ok rm {} \;
----

[[linux-command-search-grep]]
=== `grep` 命令

`grep` 的作用是在文件中提前和匹配符合条件的字符串行，命令格式如下

[source,shell]
----
[root@localhost ~]# grep [选项] "搜索内容" 文件名
----

.`grep` 选项
|===
|参数 |说明

| -A 数字
| 列出符合条件的行，并列出后续的 n 行

| -B 数字
| 列出符合条件的行，并列出前面的 n 行

| -c
| 统计找到的符合条件的字符串的次数

| -i
| 忽略大小写

| -n
| 输出行号

| -v
| 反向查找

| --color=auto
| 搜索出的关键字用颜色表示
|===

.find 和 grep 的区别
****
find 命令用于搜索在系统中符合条件的文件名。如果需要模糊查询，则使用通配符匹配，通配符是完全匹配(find 命令可以通过 `-regex` 选项，把匹配规则转为正则表达式规则，但是不建议如此)。

grep 命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式匹配，正则表达式是包含匹配。
****

.通配符和正则表达式的区别
****
通配符:用于匹配文件名，完全匹配


|===
|通配符 |作用

|?
|匹配一个任意字符

|*
|匹配 0 个或任意多个任意字符，也就是可以匹配任何内容

|[]
|匹配中括号中的任意一个字符。例如:[abc] 代表一定匹配一个字符，要么是a,要么是b,要么是c

|[-]
|匹配中括号中的任意一个字符，代表一个范围。例如 [a-z] 代表匹配一个小写字母

|[^]
|逻辑非，表示匹配不是中括号内的一个字符。例如: [^0-9] 代表匹配一个不是数字的字符
|===

正则表达式:用于匹配字符串，包含匹配

|===
|正则符 |作用

|?
|匹配前一个字符重复 0 次或者 1 次(`?` 是扩展正则，需要使用 `egrep` 命令)

|*
|匹配前一个字符重复 0 次或任意多次

|[]
|匹配中括号中的任意一个字符。例如:[abc] 代表一定匹配一个字符，要么是a,要么是b,要么是c

|[-]
|匹配中括号中的任意一个字符，代表一个范围。例如 [a-z] 代表匹配一个小写字母

|[^]
|逻辑非，表示匹配不是中括号内的一个字符。例如: [^0-9] 代表匹配一个不是数字的字符

|^
|匹配行首

|$
|匹配行尾
|===
****


下面举几个例子说明一下:

[source,shell]
----
[root@localhost ~]# grep "/bin/bash" /etc/passwd
root:x:0:0:root:/root:/bin/bash
user1:x:500:501::/home/user1:/bin/bash
user2:x:501:502::/home/user2:/bin/bash
user3:x:503:504::/home/user3:/bin/bash
# 查找有多少个可以登录的用户

[root@localhost ~]# grep -A 3 "root" /etc/passwd
# 查找包含有 root 的行，并列出后续的 3 行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
--
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin


[root@localhost ~]# grep -n "/bin/bash" /etc/passwd
# 查找有多少个可以登录的用户，显示行号
1:root:x:0:0:root:/root:/bin/bash
21:user1:x:500:501::/home/user1:/bin/bash
22:user2:x:501:502::/home/user2:/bin/bash
23:user3:x:503:504::/home/user3:/bin/bash


[root@localhost ~]# grep -v "/bin/bash" /etc/passwd
# 查找不能登录的用户，也就是伪用户
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin
saslauth:x:499:76:Saslauthd user:/var/empty/saslauth:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
----

[[linux-command-search-channel]]
=== 管道符

管道命令符的作用也可以用一句话来概括“把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入”，管道符格式如下

[source,shell]
----
[root@localhost ~]# 命令1 | 命令2
----

举例：

[source,shell]
----
[root@localhost ~]# ll -a /etc/ | more

[root@localhost ~]# netstat -an | grep "ESTABLISHED"
# 查询本地所有网络连接，提取包含 ESTABLISHED 的行
tcp        0     64 192.168.11.136:22           192.168.11.109:17665        ESTABLISHED


[root@localhost ~]# netstat -an | grep "ESTABLISHED" | wc -l
# 如果想知道具体的网络连接数量，可以使用 wc 命令统计行数
1
----

[[linux-command-package]]
== 打包与压缩

在 Linux 中可以识别的常见的压缩 格式有十几种。比如 `.zip`,`.gz`,`.bz2`,`.tar`,`.tar.gz`,`.tar.bz2`  等

[[linux-command-package-whereis]]
=== `.zip` 格式

`.zip` 格式是 Windows 中最常见的压缩格式，Linux 也可以正常识别 `.zip` 格式。这可以方便地和 Windows 系统通用压缩文件。

==== 压缩

压缩的命令就是 `zip`

* 命令名称: zip
* 英文原意: package and compress(archive) files
* 所在路径: /usr/bin/zip
* 执行权限: 所有用户
* 功能描述: 压缩文件或目录

[source,shell]
----
[root@localhost ~]# zip [选项] 压缩包名 源文件或源目录
----

选项 `-r` : 压缩目录

[source,shell]
----
[root@localhost ~]# zip ana.zip anaconda-ks.cfg
----

==== 解压

解压的命令就是 `unzip`

* 命令名称: unzip
* 英文原意: list,test and extract compressed files in a ZIP archive
* 所在路径: /usr/bin/unzip
* 执行权限: 所有用户
* 功能描述: 列表，测试和提取压缩文件中的文件

[source,shell]
----
[root@localhost ~]# unzip [选项] 压缩包名
----

选项 `-d` : 指定解压目录

[source,shell]
----
[root@localhost ~]# unzip -d /tmp/ ana.zip
----

[[linux-command-package-gz]]
=== `.gz` 格式(不会打包)

`.gz` 格式是 Linux 中最常用的压缩格式，使用 `gzip` 命令进行压缩


==== 压缩

压缩的命令就是 `gzip`

* 命令名称: gzip
* 英文原意: compress or expand files
* 所在路径: /bin/gzip
* 执行权限: 所有用户
* 功能描述: 压缩文件或目录

[source,shell]
----
[root@localhost ~]# gzip [选项] 源文件
----

.`gzip` 选项
|===
|选项 |说明

| -c
|将压缩数据输出到标准输出中，可以用于保留源文件

|-d
|解压缩

|-r
|压缩目录
|===

[source,shell]
----
[root@localhost ~]# gz -c anaconda-ks.cfg > anaconda-ks.cfg.gz
# 使用 -c 选项，可以不让压缩数据输出到屏幕上，而是重定向到压缩文件中。这样可以在压缩文件的时候不删除源文件
----

==== 解压

如果要解压 `.gz` 文件，那么可以使用 `gzip -d 压缩包` 和 `gunzip 压缩包` 命令都可以。我们看看 `gunzip` 命令的基本信息。

* 命令名称: gunzip
* 英文原意: compress or expand files
* 所在路径: /bin/gunzip
* 执行权限: 所有用户
* 功能描述: 解压缩文件或目录

[source,shell]
----
[root@localhost ~]# gunzip  anaconda-ks.cfg.gz
[root@localhost ~]# gzip -d  anaconda-ks.cfg.gz
----

[[linux-command-package-bz]]
=== `.bz2` 格式(不能压缩目录)

`.bz2` 格式是 Linux 的另一种压缩格式，从理论上来讲。`.bz2` 格式的算法更先进、压缩比更好。而 `.gz` 格式相对来讲压缩的时间更快。

==== 压缩

`.bz2` 格式的压缩命令是 `bzip2`

* 命令名称: bzip2
* 英文原意: a block-sorting file compressor
* 所在路径: /usr/bin/bzip2
* 执行权限: 所有用户
* 功能描述: 压缩

.`bzip2` 选项
|===
|选项 |说明

| -d
|解压缩

|-k
|压缩时，保留源文件

|-v
|显示压缩的详细信息
|===

[source,shell]
----
[root@localhost ~]# bzip2  anaconda-ks.cfg
[root@localhost ~]# bzip2  -k anaconda-ks.cfg
----

==== 解压

如果要解压 `.bz2` 文件，那么可以使用 `bzip2 -d 压缩包` 和 `bunzip2 压缩包` 命令都可以。我们看看 `bunzip2` 命令的基本信息。

* 命令名称: bunzip2
* 英文原意: a block-sorting file compressor
* 所在路径: /usr/bin/bunzip2
* 执行权限: 所有用户
* 功能描述: 解压缩

[source,shell]
----
[root@localhost ~]# bunzip2  anaconda-ks.cfg.bz2
[root@localhost ~]# bzip2  -d anaconda-ks.cfg.bz2
----

[[linux-command-package-tar]]
=== `.tar` 格式(打包不会压缩)

`.tar` 格式的打包和解打包都是用 `tar` 命令,区别只是选项不同。

* 命令名称: tar
* 英文原意: tar
* 所在路径: /bin/tar
* 执行权限: 所有用户
* 功能描述: 打包和解打包命令

.`tar` 选项
|===
|选项 |说明

| -c
|打包

|-f
|指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所有一定要正确指定扩展名

|-v
|显示打包/解打包过程

|-x
|解打包

|-t
|测试，就是不解打包，只是查看包中有哪些文件

|-C 目录
|指定解打包目录
|===

[source,shell]
----
[root@localhost ~]# tar -xvf  anaconda-ks.cfg.tar
----

[[linux-command-package-tars]]
=== `.tar.gz`  和 `.tar.bz2` 格式

使用 `tar` 命令直接打包压缩

[source,shell]
----
[root@localhost ~]# tar [选项] 压缩包 源文件或目录
----

-z : 压缩和解压缩 `.tar.gz` 格式
-j : 压缩和解压缩 `.tar.bz2` 格式

[source,shell]
----
[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/
# 将 /tmp/ 目录直接打包压缩为 .tar.gz 文件
[root@localhost ~]# tar -zxvf tmp.tar.gz /tmp/
# 解压缩和解打包
----

[source,shell]
----
[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/
# 将 /tmp/ 目录直接打包压缩为 .tar.bz2 文件
[root@localhost ~]# tar -jxvf tmp.tar.bz2 /tmp/
# 解压缩和解打包
----

[[linux-command-shutdown]]
== 关机和重启命令

[[linux-command-shutdown-sync]]
=== `sync` 数据同步

* 命令名称: sync
* 英文原意: flush file system buffers
* 所在路径: /bin/sync
* 执行权限: 所有用户
* 功能描述: 刷新文件系统缓冲区

[[linux-command-shutdown-shutdown]]
=== `shutdown` 数据同步

* 命令名称: shutdown
* 英文原意: bring the system down
* 所在路径: /sbin/shutdown
* 执行权限: 超级用户
* 功能描述: 关机和重启

[source,shell]
----
[root@localhost ~]# shutdown [选项] 时间 [警告信息]
----

.`shutdown` 选项
|===
|选项 |说明

| -c
|取消已经执行的 `shutdown` 命令

|-h
|关机

|-r
|重启
|===

[[linux-command-shutdown-reboot]]
=== `reboot` 数据同步

在现在的系统中，reboot 命令也是安全的，而且不需要加入过多的选项

[[linux-command-shutdown-halt]]
=== `halt` 和 `poweroff` 命令

这两个命令不会完整的关闭和保存系统的服务，不建议使用

[[linux-command-shutdown-init]]
=== `init` 命令

`init` 是修改 Linux 运行级别的命令，也可以用于关机和重启。这个命令并不安全。不建议使用

[source,shell]
----
[root@localhost ~]# init 0
# 关机，也就是调用系统的 0 级别
[root@localhost ~]# init 6
# 重启，也就是调用系统的 6 级别
----

[[linux-command-network]]
== 常用网络命令

[[linux-command-network-ip]]
=== 配置 ip 地址

配置 IP 地址有两种方法

. setup 工具
. vi /etc/sysconfig/network-scripts/ifcfg-eth0

重启网络服务

[source,shell]
----
[root@localhost ~]# service network restart
----

[[linux-command-network-ifconfig]]
=== `ifconfig` 和 `ip addr`

`ifconfig` 和 `ip addr` 命令主要是用来查看 ip 地址。`ifconfig` 在 CentOS 6 之前可以使用。`ip addr` 在 CentOS 6 之后可以使用。

* 命令名称: ifconfig
* 英文原意: configure a network interface
* 所在路径: /sbin/ifconfig
* 执行权限: 超级用户
* 功能描述: 配置网络接口

[source,shell]
----
[root@localhost home]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:15:5d:83:4c:00 brd ff:ff:ff:ff:ff:ff
    inet 192.168.11.137/24 brd 192.168.11.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::cf6e:fd49:90c1:3de2/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
----

[[linux-command-network-ping]]
=== `ping` 命令

`ping` 是常用的网络命令，主要通过 ICMP 协议进行网络探测，测试网络中主机的通信情况。

* 命令名称: ping
* 英文原意: send ICMP ECHO_REQUEST to network hosts
* 所在路径: /bin/ping
* 执行权限: 所有用户
* 功能描述: 向网络主机发送 ICMP 请求

[source,shell]
----
[root@localhost ~]# ping [选项] IP
----

.`ping` 选项
|===
|选项 |说明

| -b
|后面加入广播地址，用于对整个网段进行探测

|-c 次数
|用于指定 `ping` 的次数

|-s 字节
|指定探测包大小
|===

.探测 192.168.103.0/24 网段中有多少可以通信的主机jcohy
[source,shell]
----
[root@localhost home]# ping -b -c 3 192.168.103.255
PING 192.168.103.255 (192.168.103.255) 56(84) bytes of data.
64 bytes from 192.168.103.199: icmp_seq=1 ttl=64 time=0.522 ms
64 bytes from 192.168.103.168: icmp_seq=1 ttl=64 time=0.195 ms (DUP!)
64 bytes from 192.168.103.252: icmp_seq=1 ttl=64 time=0.195 ms (DUP!)
...
...
----

[[linux-command-network-netstat]]
=== `netstat`

`netstat` 是网络状态查看命令，既可以查看到本机开启的端口，也可以查看到有哪些客户端连接。在 CentOS 7.x 中 `netstat` 命令默认没有安装，需要安装 `net-snmp` 和 `net-tools` 软件包

* 命令名称: netstat
* 英文原意: Print network connections ,routing tables,interface statistics,masquerade connections,and multicast memberships
* 所在路径: /bin/netstat
* 执行权限: 所有用户
* 功能描述: 输出网络连接，路由表，接口统计，伪装连接和组播成员


[source,shell]
----
[root@localhost ~]# netstat [选项]
----

.`netstat` 选项
|===
|选项 |说明

| -a
| 列出所有网络状态，包括 Socket 程序

|-c 秒数
|指定每隔 几秒 刷新一下网络状态

|-p
|显示 pid 和程序名

|-t
|显示使用 TCP 协议端口的连接状况

|-u
|显示使用 UDP 协议端口的连接状况

|-l
|仅显示监听状态的连接

|-r
|显示路由表
|===

.查看本机开启的端口
[source,shell]
----
[root@localhost home]# netstat -tuln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN
tcp6       0      0 :::22                   :::*                    LISTEN
tcp6       0      0 ::1:25                  :::*                    LISTEN
udp        0      0 127.0.0.1:323           0.0.0.0:*
udp6       0      0 ::1:323                 :::*
----

各字段解释
|===
|字段 |说明

|Proto
|网络连接的协议，一般就是 TCP 或者 UDP 协议

|Recv-Q
| 表示接受到的数据，已经在本地缓存中，但是还没有被程序取走

|Send-Q
| 表示从本机发送，对方还没有收到的数据，依然在本地缓存中，一般是不具备 ACK 标志的数据包

|Local Address
| 本机的 IP 地址和端口号

|Foreign Address
| 远程主机的 IP 地址和端口号

| State
| 状态，常见的状态主要有以下几种:

* LISTEN : 监听状态，只有 TCP 协议需要监听，UDP 不需要
* ESTABLISHED : 已经建立连接的状态，如果使用 `-l` 选项，则看不到已经建立连接的选项
* SYN_SEND : SYN 发起包，就是主动发起连接的数据包
* SYN-RECV : 接收到主动连接的数据包
* FIN_WAIT1 : 正在中断的连接
* FIN_WAIT2 : 已经中断的连接，但是正在等待对方主机进行确认
* TIME_WAIT : 连接已经中断，但是套接字依然在网络中等待结束
* CLOSED : 套接字没有被使用

在这些状态中，我们最常用的就是 `LISTEN` 和 `ESTABLISHED` 状态，一种表示正在监听，一种表示已经建立连接
|===

如果使用 `-p` 选项，可以查看到是那个程序占用了端口，并且可以知道这个程序的 PID，如下:

.查看本机有哪些程序开启的端口
[source,shell]
----
[root@localhost home]# netstat -tulnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      4340/sshd
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      4635/master
tcp6       0      0 :::22                   :::*                    LISTEN      4340/sshd
tcp6       0      0 ::1:25                  :::*                    LISTEN      4635/master
udp        0      0 127.0.0.1:323           0.0.0.0:*                           3811/chronyd
udp6       0      0 ::1:323                 :::*                                3811/chronyd
----

使用选项 `-an` 可以查看所有连接，包括监听状态连接(LISTEN)，已经建立连接状态的连接(ESTABLISHED)，Socket 程序连接等。

.查看所有连接
[source,shell]
----
[root@localhost home]# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN
tcp        0     52 192.168.11.137:22       192.168.11.109:26599    ESTABLISHED
tcp6       0      0 :::22                   :::*                    LISTEN
tcp6       0      0 ::1:25                  :::*                    LISTEN
udp        0      0 127.0.0.1:323           0.0.0.0:*
udp6       0      0 ::1:323                 :::*
raw6       0      0 :::58                   :::*                    7
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ACC ]     STREAM     LISTENING     7425     /run/systemd/journal/stdout
unix  5      [ ]         DGRAM                    7428     /run/systemd/journal/socket
unix  16     [ ]         DGRAM                    7430     /dev/log
unix  2      [ ACC ]     STREAM     LISTENING     15890    /run/systemd/private
unix  2      [ ACC ]     STREAM     LISTENING     28624    private/tlsmgr
unix  2      [ ACC ]     STREAM     LISTENING     28627    private/rewrite
unix  2      [ ACC ]     STREAM     LISTENING     28630    private/bounce
unix  2      [ ACC ]     STREAM     LISTENING     28633    private/defer
unix  2      [ ACC ]     STREAM     LISTENING     28636    private/trace
unix  2      [ ACC ]     STREAM     LISTENING     28639    private/verify
unix  2      [ ACC ]     STREAM     LISTENING     28645    private/proxymap
unix  2      [ ACC ]     STREAM     LISTENING     28648    private/proxywrite
unix  2      [ ACC ]     STREAM     LISTENING     28651    private/smtp
unix  2      [ ACC ]     STREAM     LISTENING     28654    private/relay
unix  2      [ ACC ]     STREAM     LISTENING     28660    private/error
unix  2      [ ACC ]     STREAM     LISTENING     28663    private/retry
unix  2      [ ACC ]     STREAM     LISTENING     28669    private/discard
unix  2      [ ACC ]     STREAM     LISTENING     28672    private/local
unix  2      [ ACC ]     STREAM     LISTENING     28675    private/virtual
unix  2      [ ACC ]     STREAM     LISTENING     28678    private/lmtp
unix  2      [ ACC ]     STREAM     LISTENING     28681    private/anvil
unix  2      [ ACC ]     STREAM     LISTENING     28684    private/scache
unix  2      [ ACC ]     STREAM     LISTENING     28613    public/pickup
unix  2      [ ACC ]     STREAM     LISTENING     28617    public/cleanup
unix  2      [ ACC ]     STREAM     LISTENING     28620    public/qmgr
unix  2      [ ACC ]     STREAM     LISTENING     28642    public/flush
unix  2      [ ACC ]     STREAM     LISTENING     28657    public/showq
unix  2      [ ]         DGRAM                    24508    /var/run/chrony/chronyd.sock
unix  2      [ ACC ]     STREAM     LISTENING     16062    /run/lvm/lvmpolld.socket
unix  2      [ ]         DGRAM                    16065    /run/systemd/shutdownd
unix  2      [ ACC ]     SEQPACKET  LISTENING     16070    /run/udev/control
unix  2      [ ACC ]     STREAM     LISTENING     16108    /run/lvm/lvmetad.socket
unix  3      [ ]         DGRAM                    7415     /run/systemd/notify
unix  2      [ ]         DGRAM                    7417     /run/systemd/cgroups-agent
unix  2      [ ACC ]     STREAM     LISTENING     24060    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     27638    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     28646
unix  2      [ ]         DGRAM                    25340
unix  3      [ ]         STREAM     CONNECTED     24381
unix  3      [ ]         STREAM     CONNECTED     28647
unix  3      [ ]         STREAM     CONNECTED     28659
unix  3      [ ]         STREAM     CONNECTED     28649
unix  3      [ ]         STREAM     CONNECTED     28658
unix  3      [ ]         STREAM     CONNECTED     27470    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     28643
unix  3      [ ]         STREAM     CONNECTED     24555    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     28644
unix  3      [ ]         STREAM     CONNECTED     27469
unix  3      [ ]         STREAM     CONNECTED     28662
unix  3      [ ]         STREAM     CONNECTED     28667
unix  2      [ ]         DGRAM                    16950
unix  3      [ ]         STREAM     CONNECTED     28661
unix  3      [ ]         STREAM     CONNECTED     24939
unix  2      [ ]         DGRAM                    27855
unix  3      [ ]         STREAM     CONNECTED     28632
unix  3      [ ]         STREAM     CONNECTED     24940    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     28641
unix  3      [ ]         STREAM     CONNECTED     28626
unix  3      [ ]         STREAM     CONNECTED     25276    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     24425
unix  3      [ ]         STREAM     CONNECTED     28640
unix  2      [ ]         DGRAM                    25019
unix  3      [ ]         STREAM     CONNECTED     24426    /run/systemd/journal/stdout
unix  2      [ ]         DGRAM                    25256
unix  3      [ ]         STREAM     CONNECTED     28631
unix  3      [ ]         STREAM     CONNECTED     25126    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     28638
unix  3      [ ]         STREAM     CONNECTED     28625
unix  3      [ ]         STREAM     CONNECTED     28628
unix  3      [ ]         STREAM     CONNECTED     28637
unix  3      [ ]         STREAM     CONNECTED     28629
unix  3      [ ]         STREAM     CONNECTED     25125
unix  3      [ ]         STREAM     CONNECTED     28635
unix  3      [ ]         STREAM     CONNECTED     24701
unix  2      [ ]         DGRAM                    25049
unix  3      [ ]         STREAM     CONNECTED     24702    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     28614
unix  2      [ ]         DGRAM                    24253
unix  3      [ ]         STREAM     CONNECTED     28853    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     28612
unix  2      [ ]         DGRAM                    28583
unix  3      [ ]         STREAM     CONNECTED     24554    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     26046    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     26045
unix  2      [ ]         DGRAM                    23523
unix  3      [ ]         STREAM     CONNECTED     16676    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     28668
unix  2      [ ]         DGRAM                    24488
unix  3      [ ]         STREAM     CONNECTED     28686
unix  3      [ ]         STREAM     CONNECTED     28671
unix  3      [ ]         STREAM     CONNECTED     28685
unix  3      [ ]         STREAM     CONNECTED     25194
unix  3      [ ]         STREAM     CONNECTED     28670
unix  3      [ ]         STREAM     CONNECTED     27637
unix  3      [ ]         STREAM     CONNECTED     28673
unix  2      [ ]         DGRAM                    51529
unix  3      [ ]         STREAM     CONNECTED     23532
unix  3      [ ]         STREAM     CONNECTED     28674
unix  3      [ ]         STREAM     CONNECTED     16675
unix  3      [ ]         STREAM     CONNECTED     28677
unix  3      [ ]         STREAM     CONNECTED     24143    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     28676
unix  3      [ ]         STREAM     CONNECTED     28679
unix  2      [ ]         DGRAM                    16391
unix  3      [ ]         STREAM     CONNECTED     28618
unix  3      [ ]         STREAM     CONNECTED     28680
unix  3      [ ]         STREAM     CONNECTED     28683
unix  3      [ ]         STREAM     CONNECTED     28682
unix  3      [ ]         STREAM     CONNECTED     28615
unix  3      [ ]         STREAM     CONNECTED     25275
unix  3      [ ]         STREAM     CONNECTED     24142
unix  3      [ ]         STREAM     CONNECTED     27694    /run/systemd/journal/stdout
unix  2      [ ]         DGRAM                    51675
unix  3      [ ]         STREAM     CONNECTED     28634
unix  3      [ ]         STREAM     CONNECTED     24252
unix  3      [ ]         STREAM     CONNECTED     16872
unix  3      [ ]         STREAM     CONNECTED     28619
unix  3      [ ]         STREAM     CONNECTED     28852
unix  3      [ ]         STREAM     CONNECTED     25195    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     24552
unix  3      [ ]         STREAM     CONNECTED     28621
unix  3      [ ]         DGRAM                    16975
unix  2      [ ]         DGRAM                    27930
unix  3      [ ]         STREAM     CONNECTED     24553
unix  3      [ ]         STREAM     CONNECTED     28622
unix  3      [ ]         STREAM     CONNECTED     27693
unix  3      [ ]         DGRAM                    16974
unix  2      [ ]         DGRAM                    24242
unix  3      [ ]         STREAM     CONNECTED     28656
unix  3      [ ]         STREAM     CONNECTED     28611
unix  3      [ ]         STREAM     CONNECTED     28655
unix  3      [ ]         STREAM     CONNECTED     24234
unix  2      [ ]         DGRAM                    28706
unix  3      [ ]         STREAM     CONNECTED     28653
unix  2      [ ]         DGRAM                    52227
unix  3      [ ]         STREAM     CONNECTED     24235    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     28652
unix  3      [ ]         STREAM     CONNECTED     16873    /run/systemd/journal/stdout
unix  2      [ ]         DGRAM                    52388
unix  3      [ ]         STREAM     CONNECTED     28650
unix  3      [ ]         STREAM     CONNECTED     23533
----

从 Active UNIX domain sockets 开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网络服务产生的连接。我们可以在 `-an` 选项的输出中看到各种网络连接状态，而之前的 `-tuln` 选项则只能看到监听状态。

[[linux-command-network-write]]
=== `write`

* 命令名称: write
* 英文原意: send a message to another user
* 所在路径: /usr/bin/write
* 执行权限: 所有用户
* 功能描述: 向其他用户发送信息

[source,shell]
----
[root@localhost ~]# write user1 pts/1
hello
I will be in 5 minutes to restart ,please save you data
# 向在 pts/1 (远程终端 1) 登录的 user1 用户发送信息，使用 "Ctrl+D" 快捷键保存发送的数据
----

[[linux-command-network-wall]]
=== `wall`

`write` 命令用于向指定用户发送信息，而 `wall` 命令用于向所有登录用户发送信息。包括自己

[source,shell]
----
[root@localhost ~]# wall "I will be in 5 minutes to restart ,please save you data"
----

[[linux-command-network-mail]]
=== `mail`

`mail` 是 Linux 的邮件客户端命令，可以利用这个命令给其他用户发送邮件。CentOS 7 简化版默认未安装邮件，需要手动安装 `yum -y install mailx`

* 命令名称: mail
* 英文原意: send and receive Internet mail
* 所在路径: /bin/mail
* 执行权限: 所有用户
* 功能描述: 发送和接收电子邮件

.发送邮件有 user1
[source,shell]
----
[root@localhost ~]# mail user1
Subject: hello      # 邮件标题
Nice to meet you    # 邮件内容
.                   # 以 . 来结束邮件输入
----

我们接收到的邮件都保存在 `/var/spool/mail/用户名` 中，每个用户都有一个以自己的用户名命名的邮箱。

.发送文件内容:
[source,shell]
----
[root@localhost ~]# mail -s "test mail" root < /root/anaconda-ks.cfg
# 把 /root/anaconda-ks.cfg 文件的内容发送给 root 用户
----

我们在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写入到文件中，是一个不错的选择

.查看已经接收的文件
[source,shell]
----
[root@localhost home]# mail
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/spool/mail/root": 3 messages 2 new
    1 root                  Fri Oct 30 11:24  66/1953  "test mail"
>N  2 Mail Delivery System  Fri Oct 30 11:25  72/2420  "Undelivered Mail Returned to Sender"
 N  3 root                  Fri Oct 30 11:26  65/1942  "test mail"
# 未阅读 编号 发件人            时间                          标题
&
# 等待用户输入
----

`N` 表示未读邮件，之后的数字是邮件的编号，我们主要是通过这个编号来进行邮件的操作，如果我们想要查看第一封邮件，则只需输入邮件编号 `1` 就行了

我们在命令交互中使用 `?` 查看这个交互界面支持的命令

[source,shell]
----
& ?
               mail commands
type <message list>             type messages
next                            goto and type next message
from <message list>             give head lines of messages
headers                         print out active message headers
delete <message list>           delete messages
undelete <message list>         undelete messages
save <message list> folder      append messages to folder and mark as saved
copy <message list> folder      append messages to folder without marking them
write <message list> file       append message texts to file, save attachments
preserve <message list>         keep incoming messages in mailbox even if saved
Reply <message list>            reply to message senders
reply <message list>            reply to message senders and all recipients
mail addresses                  mail to specific recipients
file folder                     change to another folder
quit                            quit and apply changes to folder
xit                             quit and discard changes made to folder
!                               shell escape
cd <directory>                  chdir to directory or home if none given
list                            list names of all available commands

A <message list> consists of integers, ranges of same, or other criteria
separated by spaces.  If omitted, mail uses the last message typed.
&
----

这些交互命令是可以简化的，比如 `header` 命令，就可以直接输入 `h` 这是列出邮件标题列表的命令。常用命令解释

* headers : 列出邮件标题列表。直接输入 `h` 即可
* delete : 删除指定邮件。例如: `d 2` ，删除第二封邮件
* save : 保存邮件。可以把指定邮件保存成文件 `s 2 /tmp/test.mail`
* quit : 退出，并把已经操作过的邮件保存。
* xit : 退出，但是不保存任何操作

[[linux-command-network-top]]
=== top

[[linux-command-history]]
== 系统痕迹命令

系统中有一些重要的痕迹日志文件，比如 `/var/log/wtmp`,`/var/run/utmp` ,`/var/log/btmp` ,`/var/log/lastlog` 等日志文件，如果你用 vim 打开这些文件，你会发现这些文件是二进制乱码。这是由于这些日志保存的是系统重要的登录痕迹，
包括某个用户何时登录了系统，何时退出了系统，错误登录等重要系统信息，不能随意编辑，只能通过对应的命令来查看。

[[linux-command-history-w]]
=== `w`

* 命令名称: w
* 英文原意: show who is logged and what they are doing
* 所在路径: /usr/bin/w
* 执行权限: 所有用户
* 功能描述: 显示登录用户正在做什么。

[source,shell]
----
[root@localhost home]# w
 11:41:39 up  3:18,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.11.109   10:14    3.00s  0.04s  0.01s w
----

.第一行信息
|===
|内容 |说明

| 11:41:39
|系统当前时间

| up  3:18
|系统的运行时间(当前系统已经运行了 3 小时 18 分钟)

| 1 user
|当前登录了 1 个用户

| load average: 0.00, 0.01, 0.05
|系统在之前 1 分钟，5 分钟，10 分钟 的平均负载。如果 CPU 是单核的，则这个数值超过 `1` 就是高负载。如果 CPU 是四核的，这个值超过 `4` 就是高负载
|===

.第二行信息
|===
|内容 |说明

| USER
| 当前登录的用户

| TTY
| 登录的终端: tty1-6:本地字符终端(alt+F1-6 切换)。tty7: 本地图形终端(ctrl+alt+F7 切换，必须安装图形化界面)。pts/0-255: 远程终端

| FROM
| 登录的 ip 地址，如果是本地地址，则为空

| LOGIN@
| 登录时间

| IDLE
| 用户闲置时间

| JCPU
| 所以的进程占用的 CPU 时间

| PCPU
| 当前进程占用的 CPU 时间

| WHAT
| 用户正在进行的操作
|===

[[linux-command-history-who]]
=== `who`

`who` 命令 和 `w` 命令类似，用于查看正在登录的用户，但是显示的内容更加简单。也是查看 `/var/run/utmp` 日志

[source,shell]
----
[root@localhost ~]# who
root     pts/0        2020-10-30 11:47 (192.168.11.109)
root     pts/1        2020-10-30 11:48 (192.168.11.109)
# 用户名  登录终端         登录时间 (来源ip)
----

[[linux-command-history-last]]
=== `last`

`last` 命令是查看系统所有登录过的用户信息的。包括正在登录的用户和之前登录过的用户。这个命令查看的是 `/var/log/wtmp` 痕迹日志文件

[source,shell]
----
[root@localhost ~]# last
root     pts/1        192.168.11.109   Fri Oct 30 11:48   still logged in
root     pts/0        192.168.11.109   Fri Oct 30 11:47   still logged in
root     pts/1        192.168.11.109   Fri Oct 30 11:44 - 11:47  (00:02)
root     pts/0        192.168.11.109   Fri Oct 30 10:14 - 11:47  (01:32)
root     pts/0        192.168.11.109   Thu Oct 29 17:13 - 18:59  (01:46)
reboot   system boot  3.10.0-957.el7.x Thu Oct 29 17:12 - 11:56  (18:43)
root     pts/0        192.168.11.109   Thu Oct 29 10:28 - crash  (06:44)
root     pts/0        192.168.11.109   Wed Oct 28 17:09 - 19:01  (01:52)
root     pts/0        192.168.11.109   Fri Oct 23 11:46 - 14:21  (02:35)
root     pts/0        192.168.11.109   Thu Oct 22 14:49 - 19:00  (04:10)
# 用户名  登录终端         来源 IP 地址    登录时间 - 退出时间
reboot   system boot  3.10.0-957.el7.x Thu Oct 22 14:48 - 11:56 (7+21:07)
# 系统重启信息记录
wtmp begins Thu Oct 22 14:48:54 2020
----

[[linux-command-history-lastlog]]
=== `lastlog`

`lastlog` 命令是查看系统中所有用户最后一次的登录时间的命令，他查看的是 `/var/log/lastlog` 文件

[source,shell]
----
[root@localhost ~]# lastlog
用户名           端口     来自             最后登陆时间
root             pts/1    192.168.11.109   五 10月 30 11:48:16 +0800 2020
bin                                        **从未登录过**
daemon                                     **从未登录过**
adm                                        **从未登录过**
lp                                         **从未登录过**
sync                                       **从未登录过**
shutdown                                   **从未登录过**
halt                                       **从未登录过**
mail                                       **从未登录过**
operator                                   **从未登录过**
games                                      **从未登录过**
ftp                                        **从未登录过**
nobody                                     **从未登录过**
systemd-network                            **从未登录过**
dbus                                       **从未登录过**
polkitd                                    **从未登录过**
sshd                                       **从未登录过**
postfix                                    **从未登录过**
chrony                                     **从未登录过**
user1                                      **从未登录过**
----

[[linux-command-history-lastb]]
=== `lastb`

`lastb` 是查看错误登录信息的，查看的是 `、/var/log/btmp` 文件

[source,shell]
----
[root@localhost ~]# lastb
# 错误登录用户 终端         尝试登录时间
user1    ssh:notty    192.168.11.109   Fri Oct 30 12:00 - 12:00  (00:00)
user1    ssh:notty    192.168.11.109   Fri Oct 30 12:00 - 12:00  (00:00)

btmp begins Fri Oct 30 12:00:05 2020
----

[[linux-command-mount]]
== 挂载命令

linux 所有存储设备都必须挂载使用，包括硬盘。

* 命令名称: mount
* 所在路径: /bin/mount
* 执行权限: 所有用户

[source,shell]
----
[root@localhost ~]# mount [-l]
[root@localhost ~]# mount -a
[root@localhost ~]# mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点
# 文件系统:ext3,ext4,,iso9660
# 卷标名: 挂载指定卷标的分区，而不是安装设备文件名挂载
# 特殊选项: 可以指定挂载的额外选项，比如读写权限，同步，异步等。具体特殊选项如下表
----


.`mount` 选项
|===
|参数|说明

| atime/noatime
| 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认更新

| async/sync
| 异步/同步，默认异步

| auto/noauto
| 自动/手动。 mount -a 命令执行时，是否会自动安装 `/etc/fstab` 文件内容挂载，默认自动

| defaults
| 定义默认值，相当于 `rw`,`suid`,`dev`,`exec`,`auto`,`nouser`,`async` 这七个选项

| exec/noexec
| 执行/不执行。设定是否在文件系统中执行可执行文件，默认是 exec 执行。

| remount
| 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限

| rw/ro
| 读写/只读。文件系统挂载时，是否具有读写权限，默认 `rw`

| suid/nosuid
| 具有/不具有 SUID 权限。设定文件系统是否具有 SUID 和 SGID 的权限，默认是具有

| user/nouser
| 允许/不允许 普通用户挂载。设定文件系统是否允许普通用户挂载。默认是不允许，只有 `root` 用户才能挂载分区

| usrquota
| 写入代表文件系统支持用户磁盘配额，默认不支持

| grpquota
| 写入代表文件系统支持组磁盘配额，默认不支持
|===


=== 光盘挂载

光盘挂载的前提依然是指定光盘的设备文件名，不同版本的 Linux，设备文件名并不相同

* 在 CentOS 5.x 以前的系统，光盘设备文件名是 `/etc/hdc`
* 在 CentOS 6.x 以后的系统，光盘设备文件名是 `/etc/sr0`

不论哪个系统都有软链接 `/dev/cdrom`,与可以作为光盘的设备文件名

[source,shell]
----
[root@localhost ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom
----

用完之后记得卸载

[source,shell]
----
[root@localhost ~]# umount /dev/sr0
[root@localhost ~]# umount /mnt/cdrom
# 因为设备文件名和挂载点已经连接到以前，卸载那一个都可以
----

[NOTE]
====
卸载的需要退出光盘目录，才能正常卸载
====

=== U 盘挂载

U 盘和硬盘公用设备文件名，所有 U 盘的设备文件名不是固定的，需要手工查询。查询命令:

[source,shell]
----
[root@localhost ~]# fdisk -l
----

然后及时挂载了，挂载命令如下:

[source,shell]
----
[root@localhost ~]# mount -t vfat /dev/sdb1 /mnt/usb/
----

如果 U 盘中有中文，会发现中文是乱码，Linux 要想正常显示中文，需要具备以下两个条件

* 安装了中文编码和中文字体
* 操作终端需要支持中文显示(纯字符终端，是不支持中文编码的)

.挂载是手动指定编码
[source,shell]
----
[root@localhost ~]# mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/
----

.卸载
[source,shell]
----
[root@localhost ~]# umount /mnt/usb/
----

=== 挂载 NTFS 分区

Linux 驱动加载顺序

. 驱动直接放入系统内核之中，这种驱动主要是系统启动加载必须的驱动，数量较少。
. 驱动以模块的方式放入硬盘。大多数驱动都以这种方法保存，保存位置在 `/lib/modules/3.10-862.el7.x86_64/kernel` 中
. 驱动可以被 Linux 识别，但是系统认为这种驱动一般不常用，默认不加载。如果需要加载这种驱动，需要重新编译内核，而 NTFS 文件系统的驱动就属于这种情况
. 硬件不能被 Linux 内核识别，需要手动安装驱动。当然前提是厂商提供了该硬件针对 Linux 的驱动，否则就需要自己开发驱动了。

使用 NTFS-3G 安装 NTFS 文件系统模块

. 下载 NTFS-3G 插件
+
https://www.tuxera.com/company/open-source/[https://www.tuxera.com/company/open-source/] 下载 NTFS-3G 插件到服务器上

. 安装 NTFS-3G 插件

在编译安装 NTFS-3G 插件之前，确保 gcc 编译器已经安装。

安装就完成了，已经可以挂在和使用 Windows 的 NTFS 分区了。不过需要注意挂在分区时的文件系统不是 `ntfs`，而是 `ntfs-3g`.挂载命令如下

[source,shell]
----
[root@localhost ~]# mount -t ntfs-3g 分区设备文件名 挂载点
# 例如
[root@localhost ~]# mount -t ntfs-3g /dev/sdb1 /mnt/win
----

[[linux-command-other]]
== 其他命令

[[linux-command-other-alias]]
=== `alias` 命令

命令的别名，也就是小名。主要是用于照顾管理员习惯用的。

[source,shell]
----
[root@localhost ~]# alias
# 查询别名
[root@localhost ~]# alias 别名='原命令'
# 设定别名
----

.查询系统已定义好的别名
[source,shell]
----
[root@localhost opt]# alias
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
----

.定义别名
[source,shell]
----
[root@localhost opt]# alias 别名='原命令'
----

用命令定义的别名，是临时生效的，要想永久生效，需要写入环境变量配置文件 `/root/.bashrc`

既然我们说别名的优先级比命令高，那么命令执行时的具体顺序是什么呢？

. 执行用绝对路径或相对路径执行的命令
. 别名
. 执行 Bash 的内部命令
. 执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令

[[linux-command-other-host]]
=== 其他命令

* 查看主机名 : hostname
* 修改主机名(重启后无效) : hostname hadoop
* 修改主机名(重启后永久生效) : vi /ect/sysconfig/network
* 查看系统信息 : uname -a,uname -r
* 查看ID命令 : id -u,id -g
* 日期 : date,date +%Y-%m-%d,date +%T,date +%Y-%m-%d" "%T
* 日历 : cal 2012
* 查看文件信息 : file filename
* 查看文件大小 : du -h, du -ah
* 查看分区 : df -h
* ssh : ssh hadoop@192.168.1.1