[[linux-shell]]
= shell 编程

== 概述

=== 什么是 shell

现在我们使用的操作系统（Windows、Mac OS、Android、iOS 等）都是带图形界面的，简单直观，容易上手，对专业用户（程序员、网管等）和普通用户（家庭主妇、老年人等）都非常适用；计算机的普及离不开图形界面。

然而在计算机的早期并没有图形界面，我们只能通过一个一个地命令来控制计算机，这些命令有成百上千之多，且不说记住这些命令非常困难，每天面对没有任何色彩的“黑屏”本身就是一件枯燥的事情；这个时候的计算机还远远谈不上炫酷和普及，只有专业人员才能使用。

对于图形界面，用户点击某个图标就能启动某个程序；对于命令行，用户输入某个程序的名字（可以看做一个命令）就能启动某个程序。这两者的基本过程都是类似的，都需要查找程序在硬盘上的安装位置，然后将它们加载到内存运行。

换句话说，图形界面和命令行要达到的目的是一样的，都是让用户控制计算机。

然而，真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和命令行只是架设在用户和内核之间的一座桥梁。

由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，这样用户就能间接地使用操作系统内核了。你看，在用户和内核之间增加一层“代理”，既能简化用户的操作，又能保障内核的安全，何乐不为呢？

用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 Shell。

Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。

**Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。**

Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox 等其它软件没有什么区别。然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。

===  shell 分类

|===
|shell  类别 |易学性 |可移植性 |编辑性 |快捷键

| Bourne Shell（sh）
| 容易
| 好
| 较差
| 较差

| Korn Shell(ksh)
| 较难
| 较好
| 好
| 较好

| Bourne Again(Bash)
| 难
| 较好
| 好
| 好

| POSIX Shell(psh)
| 较难
| 好
| 好
| 较好

| C Shell(csh)
| 较难
| 差
| 较好
| 较好

| TC Shell(tcsh)
| 难
| 差
| 好
| 好
|===

Shell 的两种主要语法有 Bourne 和 C,这两种语法彼此不兼容。Bourne 家族主要包括 `sh`,`ksh`,`psh`,`zsh`；C 家族主要包括 `csh`,`tcsh`（`Bash` 和 `zsh` 在不同程度上支持 `csh` 的语法）。

我们可以通过 /etc/shells 文件来查询 Linux 支持的 shell。

[source,shell]
----
[root@localhost ~]# cat /etc/shells
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
----

== Shell 脚本的执行方式

=== echo 命令

[source,shell]
----
[root@localhost ~]# echo [选项] [输出内容]
# -e: 支持反斜线控制的字符转换（参见下表）
# -n: 取消输出后行末的换行符号(就是内容输出后不换行)
----

.控制字符
|===
|控制字符 |说明

| \\
| 输出 `\` 本身

| \a
| 输出警告音

| \b
| 退格键，也就是向左删除键

| \c
| 取消输出行末的换行符。和 `-n` 选项一致

| \e
| ESCAPE 键

| \f
| 换页符

| \n
| 换行符

| \r
| 回车键

| \t
| 制表符，TAB 键

| \v
| 垂直制表符

| \0nnn
| 按照八进制 ASCII 码表输出字符。其中 0 为数字零，nnn 是三位八进制数

| \xhh
| 按照十六进制 ASCII 码表输出字符。，hh 是两位十六进制数
|===

echo 还能输出一些有意思的东西，例如 颜色。格式为 `\e[1;选项  文字 \e[0m` ，这一分号和选项之间不能有空格。 `\e[1` 是标准格式，代表颜色的开始, `\e[0m` 代表输出颜色的结束。颜色选项如下

.颜色选项
|===
|选项 |颜色

| 30m
| 黑色

| 31m
| 红色

| 32m
| 绿色

| 33m
| 黄色

| 34m
| 蓝色

| 35m
| 洋红

| 36m
| 青色

| 37m
| 白色

| 40m
| 黑色背景

| 41m
| 红色背景

| 42m
| 绿色背景

| 43m
| 黄色背景

| 44m
| 蓝色背景

| 45m
| 洋红背景

| 46m
| 青色背景

| 47m
| 白色
|===

.举例
[source,shell]
----
[root@localhost ~]# echo "hello world"
hello world
[root@localhost ~]# echo -n "hello world"
# 加入 -n 选项后，不会换行，直接显示新行的提示符
hello world[root@localhost ~]# echo -e "\\ \a"
\
# 这个会输入 \ ,同时会在系统音响中输出一声提示音
[root@localhost ~]# echo -e "ab\bc"
ac
# 在 b 键左侧有 \b ，所以输出只有 ac
[root@localhost ~]# echo -e "a\tb\tc\nd\te\tf"
a	b	c
d	e	f
# 加入制表符 \t 和换行符 \n
[root@localhost ~]# echo -e "\0141\t\0142\t\0143\n\0144\t\0145\t\0146"
a	b	c
d	e	f
# 还是输出上面的内容，不过是按照 八进制 ASCII 码输出的
[root@localhost ~]# echo -e "\x61\t\x62\t\x63\n\x64\t\x65\t\x66"
a	b	c
d	e	f
# 还是输出上面的内容，不过是按照 十六进制 ASCII 码输出的
[root@localhost ~]# echo -e "\e[1;31m abcd \e[0m"
 abcd
# 这条命令会把 abcd 按照红色输出。
[root@localhost ~]# echo -e "\e[1;42m abcd \e[0m"
 abcd
# 这条命令会给 abcd 加上绿色的背景。
----

=== shell 脚本的执行

我们先写一个简单的脚本

[source,shell]
----
[root@localhost ~]# vi hello.sh
#!/bin/bash
# Author:jcohy

echo -e "Hello World"
----

Shell 脚本已经写好了，如何运行呢，有两种办法

.赋予执行权限，直接运行
[source,shell]
----
[root@localhost ~]# chmod +x hello.sh
[root@localhost ~]# ./hello.sh
Hello World
----
.通过 Bash 调用执行脚本
[source,shell]
----
[root@localhost ~]# bash hello.sh
Hello World
----

== Bash 的基本功能

=== 历史命令

[source,shell]
----
[root@localhost ~]# history [选项] [历史命令保存文件]
-c: 清空历史命令
-w: 把缓存中的历史命令写入历史命令保存文件。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件 `~/.bash_history` 中
----


